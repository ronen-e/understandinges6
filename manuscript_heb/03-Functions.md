<div dir="rtl">

# פונקציות

פונקציות הן חלק חשוב בכל שפת תכנות ועד אקמהסקריפט 6, פונקציות נותרו כמעט כמות שהן מאז כתיבת השפה. 
הדבר הותיר מאחוריו שובל של בעיות והתנהגות בעייתית שבגללה היה קל מאוד לטעות ולעיתים תכופות דרשה כתיבת קוד רבה רק לשם השגת מטרות פשוטות.

פונקציות כפי שהן קיימות באקמהסקריפט 6 מקדמות את השפה באופן ניכר, ומבטאות התייחסות לשנים של תלונות ובקשות מצד מפתחי ג׳אווהסקריפט. 
התוצאה הינה מספר שיפורים על גבי השיפורים שכבר התווספו באקמהסקריפט 5 שבזכותם תכנות בג׳אווהסקריפט הופך לקל ויעיל יותר.

## פונקציות עם ערכי ברירת מחדל

לפונקציות בג׳אווהסקריפט הינן בעלות תכונה מעניינת וייחודית - הן יכולות לקבל כל מספר של ארגומנטים, ללא קשר למספר הארגומנטים שניתן בהגדרת הפונקציה. זה מאפשר יצירת פונקציות שיכולות לטפל במספרים שונים של ארגומנטים, לעיתים תכופות רק על ידי כתיבת ערכי ברירת מחדל כאשר ארגומנטים לא מועברים פנימה לפונקציה. 
כעת נרחיב כיצד ערכי ברירת מחדל 
(ערכים דיפולטיביים) 
עובדים לפני ואחרי אקמהסקריפט, בנוסף להסבר על אובייקט 
`arguments`
המיוחד, 
באמצעות ביטויים
<span dir="ltr">(expressions)</span> 
בתור ארגומנטים ועוד. 
כמו כן, יוצג בפניכם אזור מת באופן זמני חדש
<span dir="ltr">(TDZ)</span>.

### ערכים דיפולטיביים באקמהסקריפט 5

באקמהסקריפט 5 וקודם לכן, היה ניתן להשתמש בשיטה הבאה על מנת ליצור פונקציה עם ערכים דיפולטיביים

<div dir="ltr">

```js
function makeRequest(url, timeout, callback) {

    timeout = timeout || 2000;
    callback = callback || function() {};

    // יתר הפונקציה

}
```

</div>

בדוגמה לעיל, שני המשתנים
`timeout` ו `callback`
הינם משתנים אופציונליים מכיוון שהם מקבלים ערך דיפולטיבי במידה ואיננו מסופק לפונקציה. 
האופרטור הלוגי 
OR 
(`||`)
תמיד מחזיר את האופרנד השני כאשר הראשון הינו ״שקרי״.
מאחר ופרמטרים שאינם מסופקים לפונקציה מקבלים את הערך 
`undefined`,
האופרטור הלוגי 
OR 
משמש לעיתים תכופות בכדי לספק ערך דיפולטיבי עבור פרמטרים חסרים. 
קיים פגם בשיטה זו, מאחר וערך תקין עבור המשתנה 
`timeout` 
יכול להיות 
`0`, 
אך הערך יוחלף ב
 `2000` 
מאחר ו
`0` 
הינו ״שקרי״ 

במקרה כזה, מומלץ לבדוק את סוג הארגומנט בעזרת 
`typeof`
כמו בדוגמה הבאה:


<div dir="ltr">

```js
function makeRequest(url, timeout, callback) {

    timeout = (typeof timeout !== "undefined") ? timeout : 2000;
    callback = (typeof callback !== "undefined") ? callback : function() {};

    // יתר הפונקציה

}
```

</div>

בעוד שגישה זו עדיפה, היא עדיין דורשת כתיבת קוד רב יחסית עבור פעולה בסיסית. 
ספריות ג׳אווהסקריפט פופולריות מלאות בדוגמאות דומות. 

### ערכים דיפולטיביים באקמהסקריפט 6

אקמהסקריפט 6 מפשטת את תהליך הוספת ערכים דיפולטיביים לפרמטרים באמצעות הוספת יכולת אתחול פרמטרים כאשר הללו אינם נתונים לנו. לדוגמה:

<div dir="ltr">

```js
function makeRequest(url, timeout = 2000, callback = function() {}) {

    // יתר הפונקציה

}
```

</div>

הפונקציה בדוגמה לעיל מצפה רק את הפרמטר הראשון כארגומנט שחובה להעבירו. שני הפרמטרים האחרים מקבלים ערכים דיפולטיביים, מה שהופך את הפונקציה לקטנה יותר מכיוון ואין צורך לכתוב קוד נוסף שבודק ערכים חסרים ומחליף אותם.

כאשר קוראים לפונקציה
<span dir="ltr">`makeRequest()`</span>
ומספקים את כל שלושת הפרמטרים, הערכים הדיפולטיביים אינם נלקחים. לדוגמה:

<div dir="ltr">

```js
// שימוש בערכים דיפולטיביים
// timeout, callback
makeRequest("/foo");

// שימוש בערכים דיפולטיביים
// callback
makeRequest("/foo", 500);

// אין שימוש בערכים דיפולטיביים
makeRequest("/foo", 500, function(body) {
    doSomething(body);
});
```

</div>

תחת אקמהסקריפט 6 המשתנה
`url`
הוא משתנה שחובה לספקו, וזוהי הסיבה שהערך
`"/foo"` 
נתון בכל שלושת הקריאות לפונקציה
<span dir="ltr">`makeRequest()`</span>. 
שני הפרמטרים שמקבלים ערכים דיפולטיביים הינם משתנים אופציונליים.

ניתן להגדיר ערך דיפולטיבי בעבור כל ארגומנט, כולל אלו שמופיעים לפני ארגומנטים ללא ערכים דיפולטיביים בהגדרת הפונקציה. 
למשל, 
הקוד בדוגמה הבאה הינו קוד תקין:

<div dir="ltr">

```js
function makeRequest(url, timeout = 2000, callback) {

    // יתר הפונקציה

}
```

</div>

בדוגמה זו, הערך הדיפולטיבי עבור המשתנה 
`timeout`
יתקבל רק כאשר הארגומנט השני איננו מסופק לפונקציה או כאשר הארגומנט השני מסופק עם הערך 
`undefined`, 
לדוגמה: 

<div dir="ltr">

```js
// שימוש בערכים דיפולטיביים
// timeout
makeRequest("/foo", undefined, function(body) {
    doSomething(body);
});

// שימוש בערכים דיפולטיביים
// timeout
makeRequest("/foo");

// אין שימוש בערכים דיפולטיביים
makeRequest("/foo", null, function(body) {
    doSomething(body);
});
```

</div>

בכל הנוגע לערכים דיפולטיביים, הערך 
`null`
נחשב לערך תקין, 
ומכאן שבעת הקריאה השלישית לפונקציה 
<span dir="ltr">`makeRequest()`</span> 
הערך הדיפולטיבי של המשתנה 
`timeout`
לא יתקבל.

### כיצד ערכים דיפולטיביים משפיעים על אוביקט ארגומנטס

חשוב לדעת שהתנהגות אוביקט
`arguments` 
שונה ביחס לערכים דיפולטיביים. 
באקמהסקריפט 5 תחת עבודה במצב לא קשיח 
<span dir="ltr">(nonstrict mode)</span> 
אוביקט 
`arguments` 
משקף שינויים בפרמטרים של הפונקציה, כאשר הועברו לתוכה
לדוגמה:

<div dir="ltr">

```js
function mixArgs(first, second) {
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d";
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs("a", "b");
```

</div>

הפלט עבור הקוד לעיל הינו:

<div dir="ltr">

```
true
true
true
true
```

</div>

אוביקט 
`arguments` 
תמיד משתנה במצב לא קשיח ומשקף שינויים בפרמטרים של הפונקציה, כאשר הם מסופקים לפונקציה  
ומכאן, כאשר המשתנים 
`first` 
ו 
`second` 
מקבלים ערכים חדשים 
גם
<span dir="ltr">`arguments[0]` </span> 
ו 
<span dir="ltr">`arguments[1]` </span> 
משתנים בהתאם, ולכן כל ההשוואות מסוג 
`===` 
מקבלות את הערך 
`true`. 

לעומת זאת,
כאשר פועלים תחת הכללים של מצב קשיח באקמהסקריפט 5, 
ההתנהגות של אוביקט 
`arguments`
משתנה. 
במצב קשיח אוביקט
`arguments`
לא משקף שינויים בפרמטרים של הפונקציה.
לדוגמה:

<div dir="ltr">

```js
function mixArgs(first, second) {
    "use strict";

    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d"
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs("a", "b");
```

</div>

הפלט הינו:

<div dir="ltr">

```
true
true
false
false
```

</div>

בדוגמה לעיל,
שינוי המשתנים 
`first` 
ו
 `second` 
אינו משפיע על אוביקט 
`arguments`, 
ולכן הפלט נראה כמצופה.

לעומת זאת,
כאשר מופיע אוביקט 
`arguments` 
בפונקציה שמשתמשת בערכים דיפולטיביים של אקמהסקריפט 6,
 יתנהג באותו אופן כמו במצב קשיח של אקמהסקריפט 5,
בלי קשר לשאלה האם הפונקציה ככלל נמצאת במצב קשיח. 
נוכחותם של ערכים דיפולטיביים גורמת לאוביקט 
`arguments`
להתנתק מן הפרמטרים בפונקציה. 
זהו פרט חשוב לדעת כאשר משתמשים באוביקט 
`arguments`
בעת הפיתוח. 
לדוגמה:

<div dir="ltr">

```js
// הפונקציה אינה פועלת במצב קשיח
function mixArgs(first, second = "b") {
    console.log(arguments.length);
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d"
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs("a");
```

</div>

הפלט הינו:

<div dir="ltr">


```
1
true
false
false
false
```

</div>

בדוגמה זו, 
הערך של 
<span dir="ltr">`arguments.length`</span> 
הינו 1 מכיוון שרק ארגומנט אחד הועבר לפונקציה 
<span dir="ltr">`mixArgs()`</span>. 
ומכאן הערך עבור 
<span dir="ltr">`arguments[1]`</span>
הינו
`undefined`, 
כמצופה, כאשר רק ארגומנט אחד מסופק לפונקציה. 
המשמעות היא שערך המשתנה 
`first` 
זהה לערך של 
<span dir="ltr">`arguments[0]`</span>. 
שינוי ערכי המשתנים 
`first` 
ו 
`second`
לא משנה את אוביקט 
`arguments` 
בשום צורה שהיא.
התנהגות זו מתקיימת הן תחת מצב קשיח והן תחת מצב רגיל, ובצורה כזו ניתן לסמוך על אוביקט 
`arguments` 
שישקף תמיד את המצב ההתחלתי של הפונקציה בעת קריאתה.

### חישוב ערכים דיפולטיביים

תכונה מעניינת של ערכים דיפולטיביים היא שהם אינם חייבים להיות ערכים פרימיטיביים. 
ניתן למשל, להריץ פונקציה כדי להחזיר ממנה את הערך הדיפולטיבי, לדוגמה:

<div dir="ltr">

```js
function getValue() {
    return 5;
}

function add(first, second = getValue()) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 6
```

</div>

כאשר הארגומנט האחרון אינו מועבר לפונקציה 
<span dir="ltr">`add()`</span>
תופעל הפונקציה 
<span dir="ltr">`getValue()`</span>
על מנת לקבל את הערך הדיפולטיבי עבור הפרמטר השני. 
 הפונקציה 
<span dir="ltr">`getValue()`</span> 
נקראת רק כאשר 
<span dir="ltr">`add()`</span> 
נקראת ללא הפרמטר השני, לא בעת הגדרת הפונקציה. 
אם הפונקציה 
<span dir="ltr">`getValue()`</span> 
הייתה נכתבת אחרת היא הייתה יכולה להחזיר ערך אחר. 
לדוגמה:

<div dir="ltr">

```js
let value = 5;

function getValue() {
    return value++;
}

function add(first, second = getValue()) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 6
console.log(add(1));        // 7
```

</div>

בדוגמה לעיל, המשתנה
`value` 
מאותחל עם הערך 
`5` 
ומעודכן בכל פעם שהפונקציה 
<span dir="ltr">`getValue()`</span> 
נקראת. 
הקריאה הראשונה לפונקציה 
<span dir="ltr">`add(1)`</span> 
מחזירה את הערך 
`6`,  
בעוד שהקריאה השנייה לפונקציה 
<span dir="ltr">`add(1)`</span> 
מחזירה את הערך 
`7` 
מכיוון שערכו של 
`value` 
השתנה. 
מפני שהערך הדיפולטיבי של המשתנה 
`second`
מתקבל רק כאשר הפונקציה 
`add`
נקראת, שינויים לאותו ערך יכולים שיתבצעו בכל עת.

W> חובה להיזהר בעת שימוש בפונקציות למתן ערכים דיפולטיביים. 
אם שכחתם את השימוש בסוגריים, לדוגמה, אם היה נכתב: 

<span dir="ltr">`second = getValue`</span> 

בדוגמה האחרונה, המשמעות הינה העברת מצביע לפונקציה עצמה במקום לערך המוחזר ממנה.

ניתן להשתמש בפרמטר קודם כערך דיפולטיבי לפרמטר שאחריו. 
לדוגמה: 

<div dir="ltr">

```js
function add(first, second = first) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 2
```

</div>

בקוד לעיל, הפרמטר
`second` 
מקבל את הערך הדיפולטיבי שזהה לערכו של המשתנה 
`first`, 
כך שהעברת ארגומנט אחד לפונקציה למעשה נותן לשני הארגומנטים
את אותו הערך. 
ולכן הקריאה לפונקציה כך:
<span dir="ltr">`add(1, 1)`</span> 
תחזיר את הערך `2` כתוצאה כמו הקריאה 
<span dir="ltr">`add(1)`</span>. 
ניתן אף להעביר את המשתנה
 `first`
לתוך פונקציה על מנת לקבל ערך דיפולטיבי עבור המשתנה 
 `second`:


<div dir="ltr">

```js
function getValue(value) {
    return value + 5;
}

function add(first, second = getValue(first)) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 7
```

</div>

בדוגמה האחרונה נותנים למשתנה 
`second` 
את הערך המוחזר כתוצאה מהפונקציה
<span dir="ltr">`getValue(first)`</span>, 
לכן בעוד שהקריאה לפונקציה
<span dir="ltr">`add(1, 1)`</span> 
מחזירה את הערך 2, 
הקריאה לפונקציה 
<span dir="ltr">`add(1)`</span> 
מחזירה את הערך 
7 
(1 + 6).

שיטה זו של הפניה לפרמטרים קודמים בעת השמת ערכים דיפולטיביים עובדת רק עבור ארגומנטים קיימים, ולכן אין גישה לארגומנטים שבאים מאוחר יותר מאשר בזמן הגדרת הפונקציה. לדוגמה:


<div dir="ltr">

```js
function add(first = second, second) {
    return first + second;
}

console.log(add(1, 1));         // 2
console.log(add(undefined, 1)); // שגיאה
```

</div>

הקריאה לפונקציה 
<span dir="ltr">`add(undefined, 1)`</span> 
זורקת שגיאה מכיוון שהפרמטר
`second`
מוגדר לאחר
`first` 
ולכן איננו זמין בתור ערך דיפולטיבי. 
על מנת להבין מדוע הדבר קורה חשוב להסביר שוב על
הנושא הקרוי
`אזור מת באופן זמני`.

### אזור מת באופן זמני בערכים דיפולטיביים

בפרק 1 דובר על האזור המת באופן זמני 
<span dir="ltr">(TDZ)</span> 
כפי שהוא נוגע למשתנים מסוג 
`let` 
ו-
`const`, 
ובאופן דומה גם לפרמטרים דיפולטיביים קייבם אזור מת באופן זמני שבו פרמטרים אינם נגישים. 
בדומה להגדרת 
`let` 
כל פרמטר מייצר קישור חדש משלו שלא ניתן לגישה לפני אתחולו. ניסיון לעשות זאת יגרום לשגיאה. 
אתחול פרמטרים מתקיים כאשר הפונקציה נקראת, או על ידי העברת ערך עבור הפרמטר או באמצעות קביעת ערך דיפולטיבי.

על מנת לחקור את האזור המת של פרמטרים דיפולטיביים ניתן להשתמש בדוגמת קוד קודמת:

<div dir="ltr">

```js
function getValue(value) {
    return value + 5;
}

function add(first, second = getValue(first)) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 7
```

</div>

הקריאות לפונקציות
<span dir="ltr">`add(1, 1)`</span> 
ו- 
<span dir="ltr">`add(1)`</span> 
למעשה מריצות את הקוד הבא על מנת ליצור את הערכים עבור הפרמטרים
`first` 
ו 
 `second`:

<div dir="ltr">

```js
// add(1, 1)
let first = 1;
let second = 1;

// add(1)
let first = 1;
let second = getValue(first);
```

</div>

כאשר הפונקציה
<span dir="ltr">`add()`</span> 
נקראת לראשונה,
הקישורים למשתנים 
`first` 
ו 
 `second`
נוצרים בתוך אזור מת מיוחד לפרמטרים
(בדומה להתנהגות משתנים מסוג 
`let`). 
בעוד שהמשתנה 
`second`
יכול שיאותחל בעזרת הערך של המשתנה
`first`
וזאת מכיוון שהמשתנה
`first`
תמיד מאותחל
קודם לכן, 
אך ההיפך אינו תמיד נכון.
לדוגמה:

<div dir="ltr">

```js
function add(first = second, second) {
    return first + second;
}

console.log(add(1, 1));         // 2
console.log(add(undefined, 1)); // שגיאה
```

</div>

בדוגמה לעיל הקריאות לפונקציות
<span dir="ltr">`add(1, 1)`</span> 
ו- 
<span dir="ltr">`add(undefined, 1)`</span> 
למעשה מתורגמות מאחורי הקלעים לקוד הבא:

<div dir="ltr">

```js
// add(1, 1)
let first = 1;
let second = 1;

// add(undefined, 1)
let first = second;
let second = 1;
```

</div>

בדוגמה לעיל הקריאה לפונקציה
<span dir="ltr">`add(undefined, 1)`</span> 
זורקת שגיאה מכיוון והמשתנה
`second`
עוד לא מאותחל בעת אתחול המשתנה
`first`.
באותו הרגע המשתנה 
`second`
שוהה בתוך האזור המת ולכן כל ניסיון לקרוא את ערכו של 
`second`
יזרוק שגיאה. 
זוהי אותה התנהגות שנצפית במשתנים מסוג 
`let`
כפי שתוארה בפרק 1. 

I> פרמטרים של פונקציה מקבלים סביבה ואזור מת בנפרד מזה של גוף הפונקציה. המשמעות של הדבר היא שערך דיפולטיבי של פרמטר אינו יכול לגשת למשתנים אשר מוגדרים בתוך גוף הפונקציה.

## פרמטרים שלא הוגדרו

הדוגמאות בפרק זה עסקו אך ורק בפרמטרים שהוגדרו בחתימת הפונקציה. 
אך פונקציות בג׳אווהסקריפט אינן מוגבלות מבחינת מספר הפרמטרים שניתן להעביר לתוך הפונקציה ללא קשר למספר הפרמטרים שהוגדרו בפועל. 
תמיד ניתן להעביר פחות או יותר פרמטרים מאלו שהוגדרו באופן רשמי. 
ערכים דיפולטיביים מציגים בצורה ברורה מתי פונקציה יכולה לקבל פחות פרמטרים, ואקמהסקריפט 6 רצתה גם לשפר את המצב שבו מעבירים יותר פרמטרים מאשר הוגדרו.

### פרמטרים לא מוגדרים באקמהסקריפט 5

עוד מתחילתה, ג׳אווהסקריפט סיפקה את אוביקט 
`arguments`
בתור דרך להתייחס לכל הפרמטרים שמועברים לפונקציה מבלי שיהיה צורך להגדיר כל אחד מהם בנפרד. 
התעסקות עם האוביקט ייתכן שתהיה מכבידה יחסית. לדוגמה, הקוד הבא:

<div dir="ltr">

```js
function pick(object) {
    let result = Object.create(null);

    // start at the second parameter
    for (let i = 1, len = arguments.length; i < len; i++) {
        result[arguments[i]] = object[arguments[i]];
    }

    return result;
}

let book = {
    title: "Understanding ECMAScript 6",
    author: "Nicholas C. Zakas",
    year: 2015
};

let bookData = pick(book, "author", "year");

console.log(bookData.author);   // "Nicholas C. Zakas"
console.log(bookData.year);     // 2015
```
</div>

הפונקציה בדוגמת הקוד פועלת בדומה לפונקציה 
<span dir="ltr">`pick()`</span> 
מתוך ספריית 
<span dir="ltr">*Underscore.js*</span> ,
שמחזירה עותק של אוביקט שמקבל אליו חלק מתכונות האוביקט המקורי. דוגמה זו מגדירה רק ארגומנט אחד ומצפה ממנו להיות האוביקט שממנו יועתקו תכונות. כל ארגומנט נוסף שמועבר לפונקציה הינו שם תכונה שאמורה להיות מועתקת מהאוביקט המקורי לתוצר הפונקציה. 

ישנם מספר דברים שיש להתייחס אליהם בפונקציה 
<span dir="ltr">`pick()`</span> 
שבדוגמה. 
ראשית, 
כלל אין זה ברור לעין שהפונקציה מסוגלת לטפל ביותר מפרמטר אחד. 
ניתן להגדיר פרמטרים נוספים אך עדיין הדבר לא ייתן אינדיקציה לכך שהפונקציה מסוגלת לקבל כל מספר של פרמטרים. 
שנית, מאחר והפרמטר הראשון מוגדר ונעשה בו שימוש בפונקציה, חובה להתחיל את חיפוש התכונות בסמן אינדקס מספר 
`1` 
במקום בסמן אינדקס מספר 
`0`. 

אקמהסקריפט 6 מציעה לנו פרמטרים מסוג רסט בכדי להתגבר על בעיות אילו.

### פרמטרים מסוג רסט

*פרמטר מסוג רסט* 
<span dir="ltr">`(Rest Parameter)`</span> 
מיוצג על ידי שלוש נקודות 
(`...`)
שבאות לפני שם הפרמטר. 
הפרמטר הופך לערך מסוג מערך 
`Array`
שמכיל את שאר הפרמטרים המועברים לפונקציה. 
זהו המקור לשם 
״rest״
(״שאר״).
כך ניתן לשכתב את הפונקציה 
<span dir="ltr">`pick()`</span> 
להשתמש בפרמטרים מסוג רסט:

<div dir="ltr">

```js
function pick(object, ...keys) {
    let result = Object.create(null);

    for (let i = 0, len = keys.length; i < len; i++) {
        result[keys[i]] = object[keys[i]];
    }

    return result;
}
```

</div>

בדוגמה לעיל, 
הפרמטר בשם
`keys`
הינו פרמטר מסוג רסט שמכיל את כל הפרמטרים המועברים לפונקציה לאחר הפרמטר בשם
`object` 
(בניגוד אל 
`arguments`, 
שמכיל את כל הפרמטרים המועברים לפונקציה, כולל הראשון
). 
המשמעות הינה שניתן לרוץ על המשתנה
`keys`
מההתחלה ועד הסוף ללא כל חשש. 
בנוסף, ניתן להתרשם בקלות שמדובר בפונקציה שמסוגלת לקבל כל מספר של פרמטרים.

I> פרמטרים מסוג רסט אינם משפיעים על תכונת 
`length`
בפונקציה, שמספקת מידע על מספר הפרמטרים המוגדרים בחתימת הפונקציה. הערך של התכונה 
<span dir="ltr">`pick()`</span> 
בעבור הפונקציה 
בדוגמה למעלה הינו 1 מכיוון שרק הפרמטר 
`object` 
נחשב עבור חישוב ערך התכונה.

#### מגבלות על פרמטרים מסוג רסט

מתקיימות שתי הגבלות לעניין פרמטרים מסוג רסט. המגבלה הראשונה היא שיהיה אך ורק פרמטר אחד מסוג רסט, ואותו פרמטר חייב להיות מוגדר אחרון. 
הקוד בדוגמה הבאה לא יעבוד:

<div dir="ltr">

```js
// Syntax error: Can't have a named parameter after rest parameters
function pick(object, ...keys, last) {
    let result = Object.create(null);

    for (let i = 0, len = keys.length; i < len; i++) {
        result[keys[i]] = object[keys[i]];
    }

    return result;
}
```

</div>

בדוגמה לעיל, הפרמטר 
`last` 
בא אחרי הפרמטר מסוג רסט בשם 
`keys`,
ולכן תיזרק שגיאת תחביר.

המגבלה השניה היא שפרמטרים מסוג רסט לא יכולים להיות מוגדרים בתוך מגדיר ערך תכונה,
<span dir="ltr">`(setter)`</span>. 
גם הקוד הבא יזרוק שגיאת תחביר:

<div dir="ltr">

```js
let object = {

    // Syntax error: Can't use rest param in setter
    set name(...value) {
        // שאר הקוד
    }
};
```

</div>

מגבלה זו קיימת מכיוון ומגדירי ערך תכונה מוגבלים לארגומנט בודד יחיד. 
פרמטרים מסוג רסט מייצגים מספר בלתי מוגבל של ארגומנטים ולכן הם אסורים לשימוש בהקשר זה.

#### השפעת פרמטרים מסוג רסט על אוביקט ארגומנטס

פרמטרים מסוג רסט נועדו להחליף את אוביקט 
`arguments`. 
במקור, אקמהסקריפט 4 סיימה את השימוש באוביקט 
`arguments` 
ובמקומו הוסיפה פרמטרים מסוג רסט על מנת לאפשר העברת מספר בלתי מוגבל של ארגומנטים לתוך פונקציות. 
בסופו של דבר, אקמהסקריפט 4 מעולם לא יצאה אל הפועל, אך הרעיון עצמו נשמר והופיע שוב באקמהסקריפט 6, למרות שאוביקט 
`arguments`
עדיין ממשיך להתקיים.

אוביקט 
`arguments`
עובד יחד עם פרמטרים מסוג רסט כאשר הוא משקף את הארגומנטים שהועברו לפונקציה בעת קריאתה, כפי שמודגם בדוגמה הקוד הבאה:

<div dir="ltr">

```js
function checkArgs(...args) {
    console.log(args.length);
    console.log(arguments.length);
    console.log(args[0], arguments[0]);
    console.log(args[1], arguments[1]);
}

checkArgs("a", "b");
```

</div>

הקריאה לפונקציה 
<span dir="ltr">`checkArgs()`</span>. 
מייצרת את הפלט הבא:

<div dir="ltr">

```
2
2
a a
b b
```

</div>

אוביקט 
`arguments`
משקף בצורה מדויקת את הפרמטרים שהועברו בפועל לפונקציה בעת קריאתה, ללא קשר לשימוש בפרמטרים מסוג רסט.

## יכולות משופרות של בנאי פונקציה

בנאי הפונקציה
<span dir="ltr">(`Function` constructor)</span>
מהווה חלק מהשפה שמאפשר ליצור פונקציות חדשות באופן דינמי. 
הארגומנטים עבור הבנאי הם הפרמטרים עבור הפונקציה והארגומנט האחרון הינו גוף הפונקציה, 
כל הארגומנטים הינם מחרוזות. 
להלן דוגמה:

<div dir="ltr">

```js
var add = new Function("first", "second", "return first + second");

console.log(add(1, 1));     // 2
```

</div>

אקמהסקריפט 6 מוסיפה לבנאי הפונקציה את האפשרות להוסיף ערכים דיפולטיביים ופרמטרים מסוג רסט. 
צריך רק להוסיף סימן
`=` 
וערך עבור שמות הפרמטרים, לדוגמה:

<div dir="ltr">

```js
var add = new Function("first", "second = first",
        "return first + second");

console.log(add(1, 1));     // 2
console.log(add(1));        // 2
```

</div>

בדוגמה זו, הפרמטר
`second` 
מקבל את ערכו של הפרמטר
`first` 
כאשר מועבר לפונקציה פרמטר בודד בלבד. 
צורת הכתיבה זהה כמו פונקציה רגילה

לגבי פרמטרים מסוג רסט, יש להוסיף 
`...` 
לפני הפרמטר האחרון, כמו בדוגמה הבא:

<div dir="ltr">

```js
var pickFirst = new Function("...args", "return args[0]");

console.log(pickFirst(1, 2));   // 1
```

</div>

הקוד בדוגמה יוצר פונקציה שמקבלת בפרמטר בודד מסוג רסט ומחזירה את הארגומנט הראשון שהועבר לפונקציה.

הוספת ערכים דיפולטיביים ופרמטרים מסוג רסט לבנאי הפונקציה מספקת לו את אותן יכולות הקיימות בצורה הרגילה להגדרת הפונקציה.

## אופרטור הפיזור

לאופרטור הפיזור
<span dir="ltr">(`spread`)</span>
קשר מסוים עם פרמטרים מסוג רסט. 
בעוד שפרמטרים מסוג רסט מאפשרים לחבר מספר ארגומנטים לתוך מערך, 
אופרטור הפיזור מאפשר לקבוע שמערך מסויים יפורק כך שכל עצמיו יועברו לפונקציה בתור ארגומנטים נפרדים. 
ראה דוגמה שמשתמש בפונקציה 
<span dir="ltr">`Math.max()`</span> 
שיכולה לקבל כל מספר של ארגומנטים ומחזירה את האחד בעל הערך המספרי הגבוה ביותר.

<div dir="ltr">

```js
let value1 = 25,
    value2 = 50;

console.log(Math.max(value1, value2));      // 50
```

</div>

כאשר מעבירים לפונקציה שני ערכים בלבד, כמו בדוגמה לעיל,
קל להשתמש בפונקציה 
<span dir="ltr">`Math.max()`</span>. 
 אך מה היה קורה אם היינו רוצים למצוא את הערך הגבוה ביותר בתוך מערך של עצמים?  
הפונקציה 
<span dir="ltr">`Math.max()`</span>. 
לא מקבלת מערכים, ולכן לפני אקמהסקריפט 6 היה צורך לבדוק את המערך בעצמנו או להשתמש ב
<span dir="ltr">`apply()`</span> 
כמו בדוגמה הבאה: 

<div dir="ltr">

```js
let values = [25, 50, 75, 100]

console.log(Math.max.apply(Math, values));  // 100
```

</div>

הקוד בדוגמה עובד אך השימוש ב
<span dir="ltr">`apply()`</span> 
בצורה זו יכול לבלבל. הוא גם מערפל את משמעות הקוד.

אופרטור הפיזור הופך את הקוד לפשוט יותר. 

במקום לקרוא לפונקציה 
<span dir="ltr">`apply()`</span> 
ניתן להעביר מערך לתוך 
<span dir="ltr">`Math.max()`</span>. 
ולהשתמש באותו תחביר 
`...` 
כמו זה שמשמש בפרמטרים מסוג רסט. 
המערך מפורק לארגומנטים בודדים שמועברים אחד אחד לפונקציה. 
כמו בדוגמה הבאה:

<div dir="ltr">

```js
let values = [25, 50, 75, 100]

// פועל באותו אופן כמו
// console.log(Math.max(25, 50, 75, 100));
console.log(Math.max(...values));           // 100
```

</div>

כעת הקריאה ל
<span dir="ltr">`Math.max()`</span> 
נראית יותר סדורה ונמנעת מן הצורך להגדיר במפורש את החיבור ל
`this` 
(שהוא הארגומנט הראשון בקריאה ל
<span dir="ltr">`Math.max.apply()`</span> 
בדוגמה הקודמת
)

ניתן לשלב את אופרטור הפיזור עם ארגומנטים אחרים. 
נניח שהיינו רוצים שלא יוחזר מספר קטן מ-0. 
ניתן להעביר את הערך הנ״ל בנפרד ועדיין להשתמש באופרטור הפיזור, לדוגמה:

<div dir="ltr">

```js
let values = [-25, -50, -75, -100]

console.log(Math.max(...values, 0));        // 0
```

</div>

בדוגמה האחרונה, הארגומנט האחרון שמועבר לפונקציה 
<span dir="ltr">`Math.max()`</span> 
הוא 
`0`, 
והוא בא לאחר שכל שאר הארגומנטים מועברים באמצעות אופרטור הפיזור.

אופרטור הפיזור מקל על שימוש במערכים בתור ארגומנטים לפונקציה. ברוב המקרים ניתן להחליף בו את השימוש בפונקציה 
<span dir="ltr">`apply()`</span> 

ניתן להשתמש באופרטור הפיזור גם עבור פונקציות שנוצרו באמצעות בנאי הפונקציה.

## התכונה name

זיהוי פונקציות יכול להפוך לדבר מאתגר בג׳אווהסקריפט בהתחשב במספר הדרכים שניתן להגדיר פונקציה.
בנוסף, השכיחות הגבוהה של פונקציות אנונימיות הופכת פתרון באגים לקשה יותר, 
מסיבות אלו, אקמהסקריפט 6 מוסיפה את התכונה
`name` 
לכל הפונקציות.

### בחירת שמות מתאימים

כל הפונקציות שרצות תחת אקמהסקריפט 6 יקבלו ערך עבור תכונת
`name`. 

ניתן לראות זאת בדוגמה הבאה שמדפיסה את תכונת 
`name`, 
עבור הגדרת פונקציה 
ועבור משתנה מסוג פונקציה.

<div dir="ltr">

```js
function doSomething() {
    // ...
}

var doAnotherThing = function() {
    // ...
};

console.log(doSomething.name);          // "doSomething"
console.log(doAnotherThing.name);       // "doAnotherThing"
```

</div>

בדוגמת הקוד האחרון לפונקציה 
<span dir="ltr">`doSomething()`</span>  
יש תכונת 
`name` 
בעל הערך
`"doSomething"` 
מכיוון שמדובר בהגדרת פונקציה רגילה. 

לפונקציה האנונימית 
<span dir="ltr">`doAnotherThing()`</span>  
יש תכונת 
`name` 
עם הערך 
`"doAnotherThing"` 
מכיוון שזהו שמו של המשתנה אליו מקושרת הפונקציה.

### מקרים מיוחדים של תכונת name

בעוד שמציאת שמות עבור פונקציות נהפכה לדבר קל, אקמהסקריפט 6 מרחיקה לכת ודואגת לכך 
*שכל* 
הפונקציות יהיו בעלות שם מתאים.
לדוגמה:

<div dir="ltr">

```js
var doSomething = function doSomethingElse() {
    // ...
};

var person = {
    get firstName() {
        return "Nicholas"
    },
    sayName: function() {
        console.log(this.name);
    }
}

console.log(doSomething.name);      // "doSomethingElse"
console.log(person.sayName.name);   // "sayName"

var descriptor = Object.getOwnPropertyDescriptor(person, "firstName");
console.log(descriptor.get.name); // "get firstName"
```

</div>

בדוגמה זו,
הערך של
<span dir="ltr">`doSomething.name`</span> 
הינו 
`"doSomethingElse"` 
מכיוון ולמשתנה עצמו ניתן אותו שם.
ערך 
`name` 
עבור 
<span dir="ltr">`person.sayName()`</span> 
הינו
`"sayName"`, 
מאחר וזהו שם המשתנה על האוביקט
`person` . 

המשתנה 
<span dir="ltr">`person.firstName`</span> 
הינו למעשה פונקציית גטר
<span dir="ltr">`(getter function)`</span> 
ולכן שמו יהיה
<span dir="ltr">`"get firstName"`</span>. 
לפונקציות סטר
<span dir="ltr">`(setter function)`</span> 
תופיע המילה 
`"set"` 
בהתאמה.
(במידה ונרצה לקבל גישה לפונקציה עצמה נצטרך להשתמש ב 
<span dir="ltr">`Object.getOwnPropertyDescriptor()`</span> 
)

ישנם כמה מקרים מיוחדים עבור שמות פונקציה. 
עבור פונקציות שנוצרו באמצעות
<span dir="ltr">`bind()`</span> 
תופיע הקידומת  
`"bound"` 
ועבור פונקציות שנוצרו באמצעות הבנאי
`Function` 
תופיע הקידומת 
`"anonymous"`, 
כמו בדוגמה הבאה:

<div dir="ltr">

```js
var doSomething = function() {
    // ...
};

console.log(doSomething.bind().name);   // "bound doSomething"

console.log((new Function()).name);     // "anonymous"
```

</div>

השם של פונקציה שעברה דרך
<span dir="ltr">`bind()`</span> 
תמיד יהיה ערך התכונה 
`name` 
של הפונקציה המקורית בתוספת הקידומת 
<span dir="ltr">`"bound "`</span>, 
ולכן שמה של הגרסה החדשה של 
<span dir="ltr">`doSomething()`</span> 
לאחר שעברה דרך 
<span dir="ltr">`bind()`</span> 
יהיה 
<span dir="ltr">`"bound doSomething"`</span> 

חשוב לזכור שהערך של תכונת 
`name`
של פונקציה לא בהכרח משקף משתנה בעל אותו שם.
תכונת
`name`
אמורה לספק מידע, לעזור בפתרון באגים, ולכן 
אינה יכולה לשמש כדי להשיג גישה לפונקציה עצמה.

## הפרדה ברורה בין שתי תכליות הפונקציה

עד וכולל אקמהסקריפט 5, לפונקציות הייתה תכלית כפולה לפיה היה ניתן לקרוא לפונקציה עם או בלי האופרטור 
`new`. 
כאשר נקראה הפונקציה בעזרת 
`new`, 
הדבר הפך את ערך המשתנה 
`this` 
בתוך הפונקציה לאוביקט חדש שמוחזר מהפונקציה. 
כפי שמודגם בדוגמת הקוד הבאה:

<div dir="ltr">

```js
function Person(name) {
    this.name = name;
}

var person = new Person("Nicholas");
var notAPerson = Person("Nicholas");

console.log(person);        // "[Object object]"
console.log(notAPerson);    // "undefined"
```

</div>

כאשר יוצרים את המשתנה 
`notAPerson`, 
קריאה לפונקציה 
<span dir="ltr">`Person()`</span> 

ללא שימוש ב 
`new` 
מחזירה את הערך 
`undefined`
(
    וגם מגדירה את תכונת
`name`
    על האוביקט הגלובלי במצב לא קשיח
). 
השימוש באות ראשונה גדולה 
(`capitalization`) 
של הפונקציה 
`Person` 
נותן לנו אינדיקציה שהפונקציה מיועדת לקריאה באמצעות 
`new`, 
כפי שנפוץ אצל מפתחי ג׳אווהסקריפט רבים. 
הבלבול הזה, לגבי התכלית הכפולה של פונקציות הוביל למספר שינויים באקמהסקריפט 6.

בג׳אווהסקריפט קיימות שתי פונקציות פנימיות, שאינן חשופות למפתחים, עבור פונקציות:
<span dir="ltr">`[[Call]]`</span> 
ו 
<span dir="ltr">`[[Construct]]`</span>. 
כאשר פונקציה נקראת ללא האופרטור 
`new`, 
מופעלת הפונקציה
<span dir="ltr">`[[Call]]`</span> 
והיא מריצה את הפונקציה כפי שהיא כתובה. 
כאשר הפונקציה נקראת עם 
`new`, 
מופעלת הפונקציה
<span dir="ltr">`[[Construct]]`</span>. 
והיא אחראית ליצירת אוביקט חדש, 
שנקרא 
*אוביקט המטרה* 
<span dir="ltr">`(new target)`</span> 
וממשיכה להריץ את הפונקציה כמות שהיא כתובה ורק המשתנה המיוחד 
 `this`
מצביע על
אוביקט המטרה. 
פונקציות שמכילות פונקציה פנימית 
<span dir="ltr">`[[Construct]]`</span> 
*נקראות *קונסטרקטורים.

I> חשוב לשים לב לכך שלא לכל הפונקציות יש פונקציה פנימית 
<span dir="ltr">`[[Construct]]`</span>, 
ולכן לא כל הפונקציות יכולות להיקרא בעזרת 
`new`. 
פונקציות מקוצרות, שידובר עליהן בהרבה תחת פרק 
״פונקציות מקוצרות״, 
אינן בעלות פונקציית 
<span dir="ltr">`[[Construct]]`</span> 
פנימית.

### בדיקת דרך הקריאה לפונקציה באקמהסקריפט 5

השיטה הנפוצה ביותר לבדוק האם פונקציה נקראה באמצעות האופרטור 
`new` 
(ומכאן על ידי קונסטרקטור)
הייתה בעזרת 
`instanceof`, 
לדוגמה:

<div dir="ltr">

```js
function Person(name) {
    if (this instanceof Person) {
        this.name = name;   // new
    } else {
        throw new Error("You must use new with Person.")
    }
}

var person = new Person("Nicholas");
var notAPerson = Person("Nicholas");  // error
```

</div>

בדוגמה זו, ערכו של המשתנה 
`this` 
נבדק כדי לבדוק האם מדובר במופע של הקונסטרקטור
`Person`, 
ואם כן,
הקוד ממשיך לרוץ כרגיל. 
במידה ו 
`this` 
איננו מופע של 
`Person` 
נזרקת שגיאה. 
הקוד עובד מפני שפונקציית
<span dir="ltr">`[[Construct]]`</span> 
יוצרת מופע חדש של 
`Person` 
ומבצעת השמה שלו למשתנה 
`this`. 
לרוע המזל, גישה זו אינה אמינה מכיוון והמשתנה 
`this` 
יכול להיות מופע של 
`Person` 
גם ללא שימוש ב
`new`, 
לדוגמה:

<div dir="ltr">

```js
function Person(name) {
    if (this instanceof Person) {
        this.name = name;   // using new
    } else {
        throw new Error("You must use new with Person.")
    }
}

var person = new Person("Nicholas");
var notAPerson = Person.call(person, "Michael");    // works!
```

</div>

הקריאה לפונקציה
<span dir="ltr">`Person.call()`</span> 
מעבירה את המשתנה 
`person` 
בתור הארגומנט הראשון, 
ולכן 
`this`
מצביע על
`person`
בתוך פונקציית הקונסטרקטור 
`Person`.
להפונקציה 
`Person`
אין דרך לדעת אם הפונקציה נקראה בדרך זו או בעזרת 
`new`.

### new.target

כדי להתגבר על בעיה זו, הוסיפו באקמהסקריפט 6 את 
*מטה-תכונה* בשם
<span dir="ltr"> `new.target`</span> 
מטה-תכונה היא שאינה שייכות לאוביקט ומספק מידע מוסף הקשור לבעליו 
(במקרה זה -
`new`). 
כאשר נקראת הפונקציה 
<span dir="ltr">`[[Construct]]`</span> 
הערך של 
<span dir="ltr">`new.target`</span> 
מצביע על המטרה שעליה הופעלל אופרטור 
`new`. 
המטרה היא בדרך כלל פונקציית הקונסטרקטור של האוביקט שיפעל בתור 
`this`
בתוך גוף הפונקציה כאשר היא רצה. 
במידה ומופעלת הפונקציה 
<span dir="ltr">`[[Call]]`</span> 
אזי 
`new.target`
תקבל את הערך 
`undefined`.

מטה-תכונה חדשה זו מאפשרת לנו לבדוק האם פונקציה נקראה בעזרת 
בדיקת הערך עבור
<span dir="ltr">`new.target`</span>  
לדוגמה:

<div dir="ltr">

```js
function Person(name) {
    if (typeof new.target !== "undefined") {
        this.name = name;   // new
    } else {
        throw new Error("You must use new with Person.")
    }
}

var person = new Person("Nicholas");
var notAPerson = Person.call(person, "Michael");    // error!
```

</div>

בעזרת שימוש ב
<span dir="ltr">`new.target`</span>  
במקום ב
<span dir="ltr">`this instanceof Person`</span>   
הקונסטרקטור
`Person`
זורק כעת שגיאה כאשר מפעילים אותו ללא 
`new`. 

כמו כן, ניתן לבדוק באמצעות שימוש ב
<span dir="ltr">`new.target`</span>  
קריאה לקונסטרקטור ספציפי.
לדוגמה:

<div dir="ltr">

```js
function Person(name) {
    if (new.target === Person) {
        this.name = name;   // using new
    } else {
        throw new Error("You must use new with Person.")
    }
}

function AnotherPerson(name) {
    Person.call(this, name);
}

var person = new Person("Nicholas");
var anotherPerson = new AnotherPerson("Nicholas");  // error!
```

</div>

בקוד שבדוגמה הערך עבור 
<span dir="ltr">`new.target`</span>  
חייב להיות 
`Person` 
על מנת לעבוד.
לאחר הקריאה ל
<span dir="ltr">`new AnotherPerson("Nicholas")`</span>  
הקריאה הבאה 
<span dir="ltr">`Person.call(this, name)` </span>  
זורקת שגיאה מפני ש 
<span dir="ltr">`new.target`</span>  
מקבלת את הערך 
`undefined`
בתוך הקונסטרקטור
`Person` 
(שנקרא בלי שימוש ב 
`new`).



W> Warning: Using `new.target` outside of a function is a syntax error.
W> אזהרה: 
כל שימוש ב 
<span dir="ltr">`new.target`</span>  
מחוץ לפונקציה יזרוק שגיאת תחביר 
<span dir="ltr">(syntax error)</span>  

באמצעות שימוש ב
<span dir="ltr">`new.target`</span>  
אקמהסקריפט 6 עזרה להבדיל בין דרכים שונות לקריאת פונקציה.
אקמהסקריפט 6 המשיכה בנוסף לחלק אחר שאינו ברור של השפה: הגדרת הפונקציה בתוך בלוק של קוד.

## פונקציות ברמת בלוק של קוד

בגרסת אקמהסקריפט 3 וקודם לכן, הגדרת פונקציה בתוך בלוק
*פונקציה ברמת בלוק של קוד*
הייתה נחשבת לשגיאה תחבירית מבחינה טכנית, 
ובכל זאת דפדפנים תמכו בכך. 
לרוע המזל, כל דפדפן שאיפשר את התחביר התנהג בצורה שונה במקצת, ולכן עדיף להימנע מהגדרת פונקציה בתוך בלוק של קוד 
(האלטרנטיבה הטובה ביותר היא לכתוב פונקציה בתור ביטוי קוד - 
`expression`
).

בניסיון להשתלט על הבעיה, מהדורה 5 של אקמהסקריפט זרקה שגיאה בכל פעם שפונקציה הייתה מוגדרת בתוך בלוק אך במצב קשיח בלבד:

<div dir="ltr">

```js
"use strict";

if (true) {

    // נזרקת שגיאה באקמהסקריפט 5 אך לא באקמהסקריפט 6
    function doSomething() {
        // ...
    }
}
```

</div>

באקמהסקריפט 5, הקוד זורק שגיאה תחבירית. 
באקמהסקריפט 6, הפונקציה 
<span dir="ltr">`doSomething()`</span>  
נחשבת למוגדרת ברמת בלוק ויכולה להיקרא בתוך אותו בלוק בה הוגדרה. 
לדוגמה: 

<div dir="ltr">

```js
"use strict";

if (true) {

    console.log(typeof doSomething);        // "function"

    function doSomething() {
        // ...
    }

    doSomething();
}

console.log(typeof doSomething);            // "undefined"
```

</div>

פונקציות ברמת בלוק מורמות לתחילת הבלוק שבו הוגדרו, ולכן הקוד 
<span dir="ltr">`typeof doSomething`</span>  
מחזיר לנו
`"function"` 
למרות שהוא מופיע לפני הגדרת הפונקציה בקוד. 
ברגע שמגיעים לסוף הבלוק  
`if` 
שבתוכו הוגדרה הפונקציה 
<span dir="ltr">`doSomething()`</span>  
היא אינה קיימת יותר

### מתי להשתמש בפונקציות ברמת בלוק

פונקציות ברמת בלוק דומות למשתנים מסוג 
`let` 
בכך שהפונקציה מפסיקה להתקיים ברגם שהקוד הרץ יוצא מתחומי הבלוק בו היא הוגדרה. 
ההבדל העיקרי הוא שהגדרות פונקציה תמיד מורמות לתחילת הבלוק העוטף. 
ביטויי פונקציה
<span dir="ltr">`(function expressions)`</span>  
שמוגדרים בעזרת 
אינם מורמים, כפי שמדגימה הדוגמה הבאה:

<div dir="ltr">

```js
"use strict";

if (true) {

    console.log(typeof doSomething);        // שגיאה

    let doSomething = function () {
        // ...
    }

    doSomething();
}

console.log(typeof doSomething);
```

</div>

בדוגמה זו, הקוד נעצר בעת הרצת הפקודה 
<span dir="ltr">`typeof doSomething`</span>  
מאחר והפונקציה  
<span dir="ltr">`doSomething()`</span>  
משויכת למשתנה מסוג 
`let` 
שעוד לא אותחל. 
ומכאן הפונקציה 
<span dir="ltr">`doSomething`</span> 
נמצאת באותו רגע באזור המת באופן זמני
<span dir="ltr">`(TDZ)`</span>  
ולכן נזרקת שגיאה. 

באפשרותנו לבחור כיצד להגדיר פונקציות 
בתוך בלוק על פי השאלה האם ברצוננו הרמה של הפונקציה או לא

### פונקציות ברמת בלוק במצב לא קשיח

אקמהסקריפט 6 מתירה פונקציות ברמת בלוק במצב לא קשיח, אך ההתנהגות שונה במקצת.
במקום להרים את הגדרת הפונקציה לתחילת הבלוק הן מורמות לתחילת הפונקציה העוטפת, ובמקרה שאין פונקציה עוטפת - לתחילת הסביבה הגלובלית.
לדוגמה:

<div dir="ltr">

```js
// ECMAScript 6 
if (true) {

    console.log(typeof doSomething);        // "function"

    function doSomething() {
        // ...
    }

    doSomething();
}

console.log(typeof doSomething);            // "function"
```

</div>

בדוגמה זו, 
<span dir="ltr">`doSomething()`</span> 
מורמת לסביבה הגלובלית כך שהפונקציה עדיין קיימת מעבר לגבולות בלוק ה 
`if`.
אקמהסקריפט 6 אוכפת התנהגות זו על מנת להסדיר ולאחד את התנהגויות הדפדפנים השונות שהיו קיימות מקודם.

## פונקציות חץ

אחד מהשינויים המעניינים של אקמהסקריפט 6 הינו הוספת 
*פונקציות חץ*
(*arrow function*). 
פונקציות חץ הן פונקציות אשר מוגדרות על ידי תחביר חדש שמשתמש ב״חץ״
<span dir="ltr">(`=>`)</span>. 
פונקציות חץ מתנהגות בצורה שונה מפונקציות רגילות במספר דרכים:

* **אין קישור למשתנים  
<span dir="ltr">`this`, `super`, `arguments`, `new.target`</span>
בתוך הפונקציה** - 
הערך עבור המשתנים 
<span dir="ltr">`this`, `super`, `arguments`, `new.target`</span>
בתוך הפונקציה הוא זה של הפונקציה העוטפת הרגילה הראשונה מעל פונקצית החץ.
(המשתנה 
`super`
מוזכר בהרחבה פרק 4).
* **אין קריאה לפונקציה עם `new`** - 
לפונקציות חץ אין פונקציית
<span dir="ltr">`[[Construct]]`</span> 
פנימית ולכן לא יכולות לשמש בתור קונסטרקטורים. פונקציות חץ זורקות שגיאה כאשר קוראים להן עם האופרטור
`new`.
* **אין prototype** - 
מאחר ולא ניתן להשתמש ב
`prototype`
עם פונקציית חץ, אין בו צורך.
התכונה
`prototype`
אינה מוגדרת עבור פונקציית חץ
* **לא ניתן לשנות את `this`** - 
הערך עבור המשתנה 
`this`
בתוך הפונקציה בלתי ניתן לשינוי. הוא נותר זהה במהלך קריאה לפונקציה
* **אין `arguments`** - 
מאחר ובפונקצית חץ אין קישור לאוביקט 
`arguments` 
ניתן להסתמך אך ורק על פרמטרים מוגדרים או פרמטרים מסוג רסט כדי לגשת לארגומנטים שסופקו לפונקציה בעת קריאתה.
* **אין פרמטרים מוגדרים בעלי אותו שם** - 
לא ניתן להגדיר פונקציית חץ עם פרמטרים זהים בשמם במצב קשיח או רגיל, בניגוד לפונקציות רגילות שלא ניתן להגדיר עבורן פרמטרים בעלי שם זהה רק במצב קשיח.

קיימות מספר סיבות להבדלים הללו. בראש וראשונה הקישור לערך 
`this`
הינו מקור נפוץ לשגיאות בג׳אווהסקריפט. 
לפעמים קשה לעקוב אחר ערכו של
`this`
בתוך פונקציה, 
דבר שיכול להוביל לשגיאות, ואילו בפונקציות חץ הבעיה אינה קיימת. שנית על יד הגבלת פונקציות חץ 
לערך 
`this`
יחיד ובודד, מנועי ריצה של ג׳אווהסקריפט יכולים להריץ את הקוד הקשור בצורה אופטימלית, בניגוד לפונקציות רגילות, אשר יכולות לשמש גם בתור קונסטרקטור או לעבור שינויים נוספים.

שאר ההבדלים מיועדים גם הם להפחית שגיאות ובלבול בעת קריאה לפונקציות. 
בכך, מנועי ריצה של הקוד יכולים להריץ קוד בצורה אופטימלית.

I> הערה: לפונקציות מוגדרת התכונה 
`name`
שפועלת לפי אותם כללים כמו פונקציות רגילות.

### כתיבת פונקציות חץ

התחביר לכתיבת פונקציות חץ מופיע במספר צורות, תלוי במטרה. 
כל הוריאציות מתחילות עם ארגומנטים לפונקציה, כשלאחר מכן מופיע סימן החץ כשלאחר מכן מופיע גוף הפונקציה. גם הארגומנטים וגם גוף הפונקציה יכולים להופיע במספר צורות שונות, תלוי בשימוש. לדוגמה פונקציה החץ בדוגמה הבאה מקבלת ארגומנט אחד ומחזירה אותו:

<div dir="ltr">

```js
var reflect = value => value;

// זהה למעשה ל:

var reflect = function(value) {
    return value;
};
```

</div>

כאשר נתון רק ארגומנט אחד לפונקציית חץ, אותו ארגומנט יכול לשמש בצורה ישירה ללא כתיבה נוספת. החץ בא לאחר מכן והביטוי לימינו מחושב ומוחזר.
גם אם לא כותבים פקודת 
`return` 
בצורה מפורשת
פונקציית החץ תחזיר את הארגומנט. 

במידה ומועבר לפונקציה יותר מארגומנט אחד, יש להקיף את הארגומנטים בסוגריים, כמו בדוגמה הבאה:

<div dir="ltr">

```js
var sum = (num1, num2) => num1 + num2;

// זהה למעשה ל:

var sum = function(num1, num2) {
    return num1 + num2;
};
```

</div>

הפונקציה 
<span dir="ltr">`sum()`</span> 
מוסיפה ארגומנט אחד לשני ומחזירה את התוצאה. 
ההבדל היחידי בין פונקציית חץ זו ובין הפונקציה 
<span dir="ltr">`reflect()`</span> 
בדוגמה הקודמת היא שהארגומנטים עטופים בסוגריים ומופרדים בפסיק
(בדומה לפונקציות רגילות). 

במידה וכלל אין לפונקציה ארגומנטים, יש להוסיף סוגריים ריקים, כמו בדוגמה הבאה:

<div dir="ltr">

```js
var getName = () => "Nicholas";

// זהה למעשה ל:

var getName = function() {
    return "Nicholas";
};
```

</div>

כאשר רוצים להשתמש בגוף פונקציה רגיל, כזה שיש בו יותר ביטויים, יש לעטוף את גוף הפונקציה בסוגריים מסולסלים ולהחזיר ערך בצורה מפורשת, 
כמו בדוגמה הבאה:

<div dir="ltr">

```js
var sum = (num1, num2) => {
    return num1 + num2;
};

// זהה למעשה ל:

var sum = function(num1, num2) {
    return num1 + num2;
};
```

</div>

ניתן להתייחס לחלק שבתוך הסוגריים כמו לזה שנמצא בפונקציה רגילה, כמובן צריך לזכור שהמשתנה 
`arguments`
אינו זמין

אם נרצה ליצור פונקציה שלא עושה דבר, יש להשתמש בסוגריים מסולסלים, כמו בדוגמה הבאה:

<div dir="ltr">

```js
var doNothing = () => {};

// זהה למעשה ל:

var doNothing = function() {};
```

</div>

סוגריים מסולסלים משמשים עבור גוף הפונקציה.
לכן כאשר רוצים להחזיר אוביקט בכתיבה מקוצרת יש לעטוף אותו בסוגריים.
לדוגמה:

<div dir="ltr">

```js
var getTempItem = id => ({ id: id, name: "Temp" });

// זהה למעשה ל:

var getTempItem = function(id) {

    return {
        id: id,
        name: "Temp"
    };
};
```

</div>

עטיפת האוביקט בסוגריים מסמנת לנו שהסוגריים המסולסלים מייצגים אוביקט ולא את גוף הפונקציה.

### הגדרת פונקציה שמופעלת מיידית

שימוש נפוץ בג׳אווהסקריפט עבור פונקציות הינו הגדרת פונקציה שמופעלת מיידית 
<span dir="ltr">`(immediately-invoked function expressions - IIFEs)`.</span> 
<span dir="ltr">`IIFEs`</span>  
מאפשרים לנו להגדיר פונקציה אנונימית ולקרוא לה באופן מיידי ללא צורך במצביע לפונקציה. 
שיטה זו יעילה במיוחד כאשר רוצים ליצור סביבה פנימית שאינה חשופה לשאר הקוד שרץ. 
לדוגמה:

<div dir="ltr">

```js
let person = function(name) {

    return {
        getName: function() {
            return name;
        }
    };

}("Nicholas");

console.log(person.getName());      // "Nicholas"
```

</div>

בקוד שבדוגמה, משתמשים ב 
IIFE  
כדי ליצור אוביקט בעל פונקציית 
<span dir="ltr">`getName()`</span>. 
הפונקציה מחזירה את ארגומנט  
`name`, 
ולמעשה הופכת את 
`name`
למשתנה פרטי בעבור האוביקט שמוחזר מהפונקציה.

ניתן להשיג את אותו דבר בעזרת שימוש בפונקציות חץ, כל עוד עוטפים את הפונקציה בסוגריים:

<div dir="ltr">

```js
let person = ((name) => {

    return {
        getName: function() {
            return name;
        }
    };

})("Nicholas");

console.log(person.getName());      // "Nicholas"
```

</div>

הסוגריים עוטפים אך ורק את הגדרת הפונקציה, אך לא מסביב לקריאה לפונקציה 
<span dir="ltr">`("Nicholas")`</span>. 
זה שונה מפונקציה רגילה, שם הסוגריים יכולים להופיע באותה צורה או אפילו מסביב לכל הפונקציה כולל הקריאה לה.

### אין קישור עבור this

אחד ממקורות השגיאה הנפוצים ביותר בג׳אווהסקריפט הינו הקישור עבור המשתנה 
`this` 
בתוך פונקציות.
מכיוון שערכו של 
`this` 
יכול להשתנות, תלוי באיזה אופן הפונקציה נקראה, ייתכן שנשפיע בטעות על אוביקט אחד בעת שהתכוונו לשנות אוביקט אחר.
למשל:

<div dir="ltr">

```js
var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", function(event) {
            this.doSomething(event.type);     // שגיאה
        }, false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
```

</div>

בדוגמת הקוד האוביקט
`PageHandler`
מיועד לטפל באינטרקציות של המשתמש בדף האינטרנט בו הקוד רץ.
הפונקציה 
<span dir="ltr">`init()`</span>. 
נקראת כדי להגדיר את אותן אינטרקציות ובהמשך לכך מגדירה פונקציה נוספת שתקרא לפונקציה
<span dir="ltr">`this.doSomething()`</span>. 
אך הקוד אינו עובד כמצופה.

הקריאה לפונקציה 
<span dir="ltr">`this.doSomething()`</span>
לא עובדת מכיוון שהמשתנה
`this` 
מצביע על האוביקט שהיה המטרה עבור אותו אירוע אינטרקציה עם הדף 
(`document`),
במקום להצביע על האוביקט 
`PageHandler`. 
אם תנסו להריץ את הקוד תיזרק שגיאה בעת שנקראת הפונקציה לטיפול באירוע כי הפונקציה
<span dir="ltr">`this.doSomething()`</span> 
לא קיימת על האוביקט 
`document`. 

ניתן לתקן זאת על ידי קישור המשתנה 
`this` 
אל האוביקט
`PageHandler` 
בצורה מפורשת על ידי שימוש בפונקציית 
<span dir="ltr">`bind()`</span> 

על הפונקציה עצמה. לדוגמה:

<div dir="ltr">

```js
var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", (function(event) {
            this.doSomething(event.type);     // עובד
        }).bind(this), false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
```

</div>

כעת הקוד עובד כמצופה, למרות שהוא נראה קצת מוזר. 
על ידי קריאה לפונקציה 
<span dir="ltr">`bind(this)`</span> 
למעשה מגדירים פונקציה חדשה כאשר המשתנה
`this`
שלה מקושר למשתנה 
`this`
הנוכחי,  
אוביקט 
`PageHandler`.
כדי להימנה מיצירת פונקציה חדשה ניתן להשתמש בפונקציית חץ.


לפונקציות חץ אין קישור למשתנה
`this` 
כך שלמעשה ערכו של 
`this` 
בתוך הפונקציה יכול להימצא על ידי חיפוש בשרשרת הסביבות. אם פונקציית החץ נמצאת בתוך פונקציה רגילה, אזי 
`this` 
יהיה זהה לזה של הפונקציה העוטפת. 
אחרת ערכו של 
`this` 
יהיה זהה לערכו של 
`this` 
בסביבה הגלובלית. 
דוגמה:

<div dir="ltr">

```js
var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click",
                event => this.doSomething(event.type), false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
```

</div>

הפונקציה שמטפלת באירועים בדוגמה זו הינה פונקציית חץ שקוראת בתורה לפונקציה
<span dir="ltr">`this.doSomething()`</span>. 
ערכו של 
`this` 
זהה לזה שנמצא בתוך הפונקציה 
<span dir="ltr">`init()`</span>. 
ולכן גרסה זו עובדת בדומה לגרסה הקודמת שהשתמשה ב
<span dir="ltr">`bind(this)`</span> 
אף שפונקציה 
<span dir="ltr">`this.doSomething()`</span>. 
אינה מחזירה ערך, זהו הקוד היחיד שרץ בתוך גוף הפונקציה, ולכן אין צורך לכלול סוגריים מסולסלים.

פונקציות חץ נועדו לשמש כפונקציות למטרות פשוטות ולכן אינן יכולות להגדיר סוג חדש.
לכן אין להן תכונת
`prototype` 
כמו שיש לפונקציות רגילות. 
אם מנסים להשתמש באופרטור
`new`
על פונקציית חץ תיזרק שגיאה. כמו בדוגמה הבאה:

<div dir="ltr">

```js
var MyType = () => {},
    object = new MyType();  // שגיאה
```

</div>

בדוגמת הקוד האחרונה הקריאה לפונקציה
<span dir="ltr">`new MyType()`</span>. 
נכשלת מכיוון שהפונקציה 
`MyType` 
היא פונקציה חץ ולכן אין לה את התכונה הפנימית 
<span dir="ltr">`[[Construct]]`</span> 
שמאפשרת התנהגות זו. 
הידיעה שפונקציות חץ אינן יכולות לעבוד עם אופרטור 
`new`
מאפשר למנועי ריצה של ג׳אווהסקריפט לייעל את ריצת הקוד.

מאחר וערכו של המשתנה 
`this` 
נקבע על ידי הפונקציה העוטפת שבה מוגדרת פונקציית החץ,
לא ניתן לשנות את ערכו של 
`this` 
באמצעות שיטות כמו 
<span dir="ltr">`call()`, `apply()`, `bind()`.</span> 

### פונקציות חץ ומערכים

התחביר המקוצר עבור פונקציות חץ הופך אותן למתאימות במיוחד לשימוש בעיבוד מערכים. 
לדוגמה, אם נרצה למיין מערך נכתוב בד״כ קוד כזה:

<div dir="ltr">

```js
var result = values.sort(function(a, b) {
    return a - b;
});
```

</div>

זוהי כתיבה ארוכה עבור הליך פשוט. אילו היינו משתמשים בפונקציית חץ היינו כותבים כך:

<div dir="ltr">

```js
var result = values.sort((a, b) => a - b);
```

</div>

פונקציות של מערך שמקבלות פונקציית קולבק כגון 
<span dir="ltr">`sort()`, `map()`, `reduce()`</span> 
ירוויחו כולן משימוש בפונקציות חץ שהופכות קוד מורכב למראית לקוד פשוט וקריא יותר.

### אין קישור לאוביקט arguments

אף על פי שפונקציות חץ לא מקבלות גישה לאוביקט 
`arguments`
משלהן, אפשר שיעשו זאת לאוביקט 
`arguments`
מהפונקציה שעוטפת אותן. 
אותו אוביקט 
`arguments`
ניתן לגישה ללא קשר למיקום בו רצה פונקציית החץ. 
לדוגמה:

<div dir="ltr">

```js
function createArrowFunctionReturningFirstArg() {
    return () => arguments[0];
}

var arrowFunction = createArrowFunctionReturningFirstArg(5);

console.log(arrowFunction());       // 5
```

</div>

בתוך הפונקציה 
<span dir="ltr">`createArrowFunctionReturningFirstArg()`</span> 
המשתנה בתוך
`arguments[0]`
נקרא על ידי פונקצית החץ. 
אותו משתנה מכיל את הארגומנט הראשון ממסופק לפונקציה 
<span dir="ltr">`createArrowFunctionReturningFirstArg()`</span>. 
כאשר פונקצית החץ נקראת מאוחר יותר היא מחזירה את הערך 
`5`
שהיה ערך הארגומנט הראשון שהועבר לפונקציה
<span dir="ltr">`createArrowFunctionReturningFirstArg()`</span>. 
למרות שקוראים לפונקצית החץ מחוץ לסביבת הפונקציה שיצרה אותה במקור, 
האוביקט 
`arguments`
נשאר נגיש הודות לכללי הגישה של משתנים בתוך סביבות בג׳אווהסקריפט.

### זיהוי פונקציות חץ

למרות התחביר השונה, פונקציות חץ הן עדיין פונקציות, לא משנה כיצד הן מופיעות.
לדוגמה:

<div dir="ltr">

```js
var comparator = (a, b) => a - b;

console.log(typeof comparator);                 // "function"
console.log(comparator instanceof Function);    // true
```

</div>

בדוגמה ניתן לראות כי
`typeof` 
ו 
`instanceof` 
מתייחסים אל פונקציות חץ כמו פונקציות רגילות

בדומה לפונקציות רגילות גם על פונקציות חץ ניתן להשתמש ב 
<span dir="ltr">`call()`, `apply()`, `bind()`</span>, 
מלבד העובדה שהמשתנה 
`this` 
של הפונקציה לא ישתנה. 
לדוגמה:

<div dir="ltr">

```js
var sum = (num1, num2) => num1 + num2;

console.log(sum.call(null, 1, 2));      // 3
console.log(sum.apply(null, [1, 2]));   // 3

var boundSum = sum.bind(null, 1, 2);

console.log(boundSum());                // 3
```

</div>

בדוגמה זו הפונקציה
<span dir="ltr">`sum()`</span>
נקראת באמצעות
<span dir="ltr">`call()`</span>
וגם על ידי 
<span dir="ltr">`apply()`</span> 
ומקבלת ארגומנטים. 
המתודה 
<span dir="ltr">`bind()`</span> 
משמשת כדי ליצור את הפונקציה 
<span dir="ltr">`boundSum()`</span> 
עם קישור ישיר לשני ארגומנטים
`1` 
ו
`2` 
בהתאמה, כך שאין צורך להעביר אותם בעת הקריאה לפונקציה.

פונקציות חץ מתאימות לשימוש במקומות בהם משתמשים כבר בפונקציה אנונימית כמו שנפוץ לעשות עם פונקציות קולבק.
החלק הבא סוקר שינוי משמעותי נוסף באקמהסקריפט 6, הפעם מדובר בשינוי פנימי של השפה שאינו כולל תחביר חדש.

## ייעול רקורסיית זנב

אחד השינויים המעניינים באקמהסקריפט 6 הינו ייעול מנוע הריצה שמשפר את השימוש ברקורסיית זנב.
*רקורסיית זנב* 
<span dir="ltr">`(tail call)`</span> 
מתקבלת כאשר פונקציה נקראת בתור ההצהרה האחרונה של פונקציה, 
כמו בדוגמה הבאה:

<div dir="ltr">

```js
function doSomething() {
    return doSomethingElse();   // tail call
}
```

</div>

רקורסיות זנב באקמהסקריפט 5 מטופלות בדומה לקריאות פונקציה אחרות: 
מקטע זכרון חדש נוצר ונדחף לתוך מחסנית הקריאות על מנת לייצג את הקריאה לפונקציה. 
המשמעות היא שכל מקטע זכרון קודם נשמר בזכרון, דבר שיכול להפוך לבעיה כאשר מחסנית הקריאות גודלת יותר מדי.

### מה השתנה?

אקמהסקריפט 6 ביקשה להקטין את גודל מחסנית הקריאות עבור רקורסיות זנב במצב קשיח 
(במצב נורמלי רקורסיות זנב מתנהגות כרגיל). 
באמצעות אופטימיזציה זו, במקום ליצור מקטע זכרון חדש, משתמשים במקטע הזכרון הקיים כל עוד מתקיימים התנאים הבאים:

1. רקורסיית הזנב לא ניגשת למשתנים בתוך מקטע הזכרון הקיים 
(כלומר הפונקציה אינה פונקצית סגור - closure)
1. הפונקציה שקוראת לרקורסיית הזנב אינה מבצעת פעולה נוספת לאחר שרקורסיית הזנב חוזרת.
1. התוצאה של רקורסיית הזנב מוחזרת בתור ערך הפונקציה

הקוד בדוגמה הבאה עומד בכל שלושת התנאים:


<div dir="ltr">

```js
"use strict";

function doSomething() {
    // optimized
    return doSomethingElse();
}
```

</div>

הפונקציה בדוגמה מבצעת רקורסיית זנב לפונקציה 
<span dir="ltr">`doSomethingElse()`</span>, 
מחזירה את התוצאה מייד ואינה ניגשת לאף משתנה בסביבה המקומית של הפונקציה. שינוי אחד קטן, כמו לא להחזיר את התוצאה יהפוך את הפונקציה ללא מתאימה לאופטימיזציה: 

<div dir="ltr">

```js
"use strict";

function doSomething() {
    // אין אופטימיזציה - הערך אינו מוחזר
    doSomethingElse();
}
```

</div>

באופן דומה, אם הפונקציה מבצעת פעולה נוספת אחרי שהערך מוחזר מרקורסיית הזנב, גם אז הפונקציה לא תעבור אופטימיזציה:

<div dir="ltr">

```js
"use strict";

function doSomething() {
    // not optimized - must add after returning
    return 1 + doSomethingElse();
}
```

</div>

בדוגמה זו מוסיפים 1 לערך המוחזר מהפונקציה 
<span dir="ltr">`doSomethingElse()`</span> 
לפני שמחזירים את הערך הסופי וזה מספיק בשביל לא להפעיל אופטימיזציה. 

דרך נוספת לבטל אופטימיזציה ללא כוונה היא שמירת התוצאה של הפונקציה בתוך משתנה ואז להחזיר את התוצאה, 
לדוגמה:

<div dir="ltr">

```js
"use strict";

function doSomething() {
    // אין אופטימיזציה - הקריאה לפונקציה אינה מוחזרת מיד
    var result = doSomethingElse();
    return result;
}
```

</div>

הקוד בדוגמה לא יעבור אופטימיזציה כיוון שהערך המוחזר מהקריאה של
<span dir="ltr">`doSomethingElse()`</span> 
אינו מוחזר מיידית.

מאחר ולפונקציות סגור
<span dir="ltr">`(closures)`</span>  
יש גישה למשתנים בתוך הסביבה העוטפת הדבר יכול לבטל אופטימיזציה. 
לדוגמה:

<div dir="ltr">

```js
"use strict";

function doSomething() {
    var num = 1,
        func = () => num;

    // אין אופטימיזציה - פונקציית סגור
    return func();
}
```

לפונקציות הסגור
<span dir="ltr">`func()`</span>  
יש גישה למשתנה הלוקאלי 
`num`. 
למרות שהקריאה לפונקציה 
<span dir="ltr">`func()`</span>  
מחזירה מיד את התוצאה, 
לא ניתן לבצע אופטימיזציה בגלל השימוש במשתנה 
`num`.

### שימוש באופטימיזציה של רקורסיית זנב

ברמה הפרקטית, אופטימיזציה של רקורסיית זנב מתרחשת מאחורי הקלעים, כך שאין צורך לחשוב על כך אלא אם בכוונתם לייעל פונקציה. 
השימוש העיקרי באופטימיזציה של רקורסיית זנב הינו בפונקציות רקורסיביות ממילא, שם יהיה לאופטימיזציה את האפקט המירבי. 
נשתמש כדוגמה בפונקציה הבאה שמחשבת עצרת:

<div dir="ltr">

```js
function factorial(n) {

    if (n <= 1) {
        return 1;
    } else {

        // אין אופטימיזציה - מתבצעת פעולת כפל לאחר חזרת הערך
        return n * factorial(n - 1);
    }
}
```

</div>

צורה זו של הפונקציה לא יכולה לעבור אופטימיזציה, מכיוון שמתבצעת פעולת כפל לאחר הקריאה הרקורסיבית לפונקציה 
<span dir="ltr">`factorial()`</span>. 
אם המשתנה 
`n` 
הינו מספר גדול מאוד, 
גודל מחסנית הקריאות יגדל ויוכל להוביל לשגיאת גלישת מחסנית
<span dir="ltr">`stack overflow`</span>. 

כדי לייעל את הפונקציה, יש לוודא שפעולת הכפל לא מתבצעת לאחר הקריאה האחרונה לפונקציה. 
לשם כך ניתן להשתמש במשתנה שיוציא את פעולת הכפל מחוץ לפקודת 
`return`.
הפונקציה החדשה נושאת איתה את התוצאה הזמנית לקריאה הבא לפונקציה, וכך נוצרת פונקציה שמתנהגת בצורה דומה אך 
*ניתנת לאופטימיזציה*.
להלן הקוד:

<div dir="ltr">

```js
function factorial(n, p = 1) {

    if (n <= 1) {
        return 1 * p;
    } else {
        let result = n * p;

        // עובר אופטימיזציה
        return factorial(n - 1, result);
    }
}
```

</div>

בגרסה חדשה זו של הפונקציה 
<span dir="ltr">`factorial()`</span>. 
התווסף הארגומנט 
`p` 
כפרמטר עם ערך התחלתי 1. 
הפרמטר מקבל את תוצאת הכפל הקודמת. 
כאשר המשתנה
`n` 
גדול מ-1 פעולת הכפל מתבצעת ומועברת בתור הארגומנט השני לפונקציה
<span dir="ltr">`factorial()`</span>. 
זה מאפשר למנוע הריצה של ג׳אווהסקריפט לבצע אופטימיזציה של הקריאה הרקורסיבית תחת אקמהסקריפט 6.

אופטימיזציה של רקורסיית זנב הינה דבר שכדאי לחשוב עליו בעת כתיבת פונקציה רקורסיבית, מכיוון והיא נותנת שיפור ביצועים משמעותי, בייחוד כאשר היא מתבצעת בסביבת קוד שדורש משאבים רבים בעת ריצתו.

## סיכום

פונקציות לא עברו שינוי גדול מאוד באקמהסקריפט 6, אלא עברו סדרה של שינויים הדרגתיים שהופכים אותן לקלות יותר לשימוש.

פרמטרים דיפולטיביים מאפשרי לנו להגדיר בקלות באיזה ערך להשתמש כאשר ארגומנט מסוים לא מועבר לפונקציה. קודם לאקמרסקריפט 6, הדבר היה דרוש קוד נוסף בתוך גוף הפונקציה, הן לבדוק את קיום הארגומנט והן לתת לו ערך. 

פרמטרים מסוג רסט מאפשרים לנו להגדיר מערך שבו יהיו כל יתר הארגומנטים לפונקציה. 
על ידי שימוש במערך אמיתי ובזכות האפשרות להגדיר בדיוק אלו פרמטרים לכלול מתקבל פתרון גמיש בהרבה מאשר אוביקט 
`arguments`. 

אופרטור הפיזור מתלווה לפרמטרים מסוג רסט, ומאפשר לנו לפצל מערך לפרמטרים נפרדים בעת קריאה לפונקציה. 
לפני אקמהסקריפט 6, היו רק שתי דרכים להעביר פרמטרים נפרדים בתוך מערך: 
על ידי הגדרה מפורשת עבור כל פרמטר עבור באמצעות המתודה 
<span dir="ltr">`apply()`</span>. 
בעזרת אופרטור הפיזור ניתן בקלות להעביר מערך לפונקציה מבלי להתייחס לערך 
`this`
שבתוך הפונקציה.

התוספת של התכונה
`name`
באופן כולל לפונקציות מאפשר בקלות לזהות פונקציות לצרכי פתרון שגיאות ושימוש כללי. בנוסף לכך, אקמהסקריפט 6 מגדירה באופן ברור את התנהגות פונקציות ברמת בלוק כך שהן לא נחשבות לשגיאת תחביר במצב קשיח.

באקמהסקריפט 6 התנהגותה של פונקציה מוגדרת על ידי התכונה הפנימית 
<span dir="ltr">`[[Call]]`</span> 
עבור הרצה רגילה של הפונקציה, 
ועל ידי התכונה הפנימית 
<span dir="ltr">`[[Construct]]`</span> 
כאשר הפונקציה נקראת על ידי האופרטור 
`new`.
המטה-תכונה 
<span dir="ltr">`new.target`</span> 
מאפשרת לנו לקבוע עם הפונקציה נקראה באמצעות האופרטור
`new`.

השינוי הגדול ביותר עבור פונקציות באקמהסקריפט 6 היה הוספת פונקציות חץ. פונקציות חץ נועדו במקור להחליף שימוש בפונקציות אנונימיות. יש להן תחביר מתומצת יותר, קישור 
לקסיקלי
למשתנה 
`this` 
ואין להן אוביקט 
`arguments` 
משלהן.
בנוסף לכך, פונקציות חץ אינן מסוגלות לשנות את הקישור שלהן למשתנה 
`this` 
ולכן אינן יכולות לשמש בתור קונסטרקטור.

אופטימיזציה של רקורסיית זנב מאפשרת לנו לבצע אופטימיזציה של סוגים מסוימים של קריאות לפונקציה על ידי שימוש במחסנית קריאות קטנה יותר, 
שימוש בפחות זיכרון 
ומניעת שגיאות של גלישת זיכרון. 
האופטימיזציה מתבצעת באופן פנימי על ידי מנוע הריצה של ג׳אווהסקריפט כאשר הדבר אפשרי, 
אך יחד עם זאת באפשרותך לשכתב פונקציות רקרוסיביות קיימות כדי לנצל את האופטימיזציה.

</div>