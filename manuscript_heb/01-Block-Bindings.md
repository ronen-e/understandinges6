<div dir="rtl">

# שיוך משתנים לבלוקים של קוד

הגדרת משתנים הייתה תמיד חלק בעייתי בג׳אווהסקריפט. 
ברוב השפות מבוססות שפת סי, משתנים נוצרים באותו מקום בקוד בו הם מוגדרים. 
המצב שונה בשפת ג׳אווהסקריפט. 
אופן ההגדרה של המשתנה תלוי בצורת הכתיבה, והמהדורה השישית של השפה נותנת אפשרויות חדשות לשליטה בהגדרת המשתנה והסביבה אליה הוא שייך
(scope). 
פרק זה מראה מדוע הגדרת משתנים מסוג 
`var` 
יכולה ליצור בלבול, מציגה משתנים חדשים שמשוייכים מבחינת הסביבה שלהם לבלוקים של קוד 
ומציעה מספר שיטות מומלצות כיצד להשתמש בהם.

## הגדרת משתנים מסוג ״var״ ו״הרמת״ משתנים

מתייחסים להגדרת משתנים מסוג
`var` 
כאילו הוגדרו בראשית הפונקציה 
(או בסביבה הגלובלית, במידה והוגדרו מחוץ לפונקציה) 
ואין זה משנה כלל וכלל היכן המשתנה מוגדר בעת הכתיבה. התנהגות זו נקראת ״הרמת משתנים״. 
לדוגמה:

<div dir="ltr">

```js
function getValue(condition) {

    if (condition) {
        var value = "כחול";

        // קוד נוסף

        return value;
    } else {

        // המשתנה ״value״ קיים ומכיל את הערך ״undefined״

        return null;
    }

    // המשתנה ״value״ קיים ומכיל את הערך ״undefined״
}
```

</div>

אם ג׳אווהסקריפט היא שפה חדשה עבורכם ייתכן ותצפו מהמשתנה 
`value` 
שיתקיים אך ורק אם המשתנה 
`condition`
מקבל ערך מסוג ״אמת״. 
למעשה, המשתנה 
`value` 
נוצר ללא קשר לערך המשתנה
`condition`. 
מאחורי הקלעים סביבת הריצה משנה את הפונקציה 
`getValue`: 

<div dir="ltr">

```js
function getValue(condition) {

    var value;

    if (condition) {
        value = "כחול";

        // קוד נוסף

        return value;
    } else {

        return null;
    }
}
```

</div>

ההגדרה של המשתנה 
`value` 
מורמת לתחילת הפונקציה בעוד שפעולת ההשמה והאתחול נשארת כפי שהייתה. המשמעות היא שהמשתנה 
`value` 
קיים ונגיש גם בתוך הבלוק של 
`else`. 
במידה וניגשים למשתנה הוא יהיה בעל הערך 
`undefined` 
מאחר ולא אותחל לערך אחר.

לעיתים קרובות לוקח זמן עבור 
מפתחי ג׳אווהסקריפט חדשים להתרגל לעקרון ״ההרמה״ וחוסר הבנה של ההתנהגות יוצאת הדופן של השפה יכולה להוביל לבאגים. מסיבה זו אקמהסקריפט 6 הוסיפה אפשרות להגדיר משתנים שמשויכים לבלוקים של קוד ולא עבור פונקציות ועל ידי כך לשלוט בצורה טובה יותר על המשתנים שנוצרים בעת כתיבת הקוד.

## הגדרות משתנים ברמת בלוק

הגדרות משתנים ברמת בלוק הן הגדרות שלא נגישות מחוץ לסביבת בלוק של קוד קיים.
סביבת בלוק, שנקראת גם בשם סביבה לקסיקלית נוצרת:

1. בתוך פונקציה
1. בתוך בלוק של קוד. 

בלוק של קוד תחום בין התווים 
`{ }`

שיוך סביבה לבלוק של קוד הינה הדרך בה עובדות שפות רבות מבוססות שפת סי, וההוספה של הגדרות ברמת בלוק של קוד באקמהסקריפט 6 נועדה להביא את אותה רמת גמישות
(ואחידות)
לשפה.

### הגדרות מסוג let

הגדרת משתנה מסוג 
`let`
זהה מבחינת כתיבה להגדרת משתנה מסוג 
`var`. 
ברמה הבסיסית 
אפשר להחליף הגדרת
`var`
בהגדרת 
`let`
ובכך להגביל את שיוך המשתנה לבלוק הקוד הנוכחי 
(ישנם מספר הבדלים נוספים שיורחב עליהם בהמשך). 

מאחר והגדרות מסוג
`let`
אינן מורמות לתחילת בלוק הקוד הנוכחי, ייתכן ותרצה לכתוב הגדרות משתנים אלו בתחילת הבלוק, כך שיהיו נגישות עבור כל הבלוק. 

להלן דוגמה:

<div dir="ltr">

```js
function getValue(condition) {

    if (condition) {
        let value = "כחול";

        // קוד אחר

        return value;
    } else {

        // המשתנה value אינו קיים כאן

        return null;
    }

    // המשתנה value אינו קיים כאן
}
```

</div>

גרסא זו של הפונקציה 
`getValue` 
מתנהגת בצורה דומה לאיך שמצופה משפות מבוססות שפת סי. מאחר והמשתנה בשם 
`value` 
מוגדר באמצעות 
`let` 
ההגדרה אינה מורמת לתחילת הפונקציה, והמשתנה 
`value` 
אינו נגיש ברגע שהקוד גולש מחוץ לבלוק ה 
`if`. 

אם התנאי 
`condition` 
מקבל ערך ״שקרי״ 
אזי המשתנה בשם 
`value` 
לא יוגדר ולא יאותחל לו ערך

### אין להגדיר שנית

אם משתנה מסוג 
`let`
כבר הוגדר בתוך סביבה, אז שימוש נוסף של 
`let` 
באותה הסביבה יגרום לשגיאה. לדוגמה:

<div dir="ltr">

```js
var count = 30;

// Syntax error
let count = 40;
```

</div>

בדוגמה למעלה המשתנה 
`count`
מוגדר פעמיים: פעם אחת באמצעות 
`var` 
ופעם נוספת באמצעות 
`let`. 
מאחר ומשתנה מסוג 
`let` 
אינו יכול להגדיר מחדש משתנה שכבר קיים באותה הסביבה, תיזרק שגיאה. 
ואולם, לא תיזרק שגיאה אם הגדרת 
`let` 
מייצרת משתנה חדש עם אותו שם כמו משתנה בסביבה החיצונית, כפי שמדגים הקוד הבא:

<div dir="ltr">

```js
var count = 30;

// לא נזרקת שגיאה
if (condition) {

    let count = 40;

    // קוד אחר
}
```

</div>

הגדרה מסוג 
`let`
לא זורקת שגיאה מאחר והיא יוצרת משתנה חדש בשם 
`count` 
בתוך בלוק של הצהרת 
`if`, 
וזאת במקום לייצר את המשתנה בסביבה החיצונית לבלוק. 
בתוך בלוק ה - 
`if` 
המשתנה החדש שנוצר ״דורס״ את משתנה 
`count` 
החיצוני

### הגדרת משתנים קבועים

באקמהסקריפט 6 ניתן להגדיר משתנים בעזרת המזהה 
`const`. 
משתנים שמוגדרים על ידי
`const` 
נחשבים למשתנים *קבועים*, כלומר הערכים שהושמו בהם אינם ניתנים לשינוי.
מסיבה זו חובה לאתחל כל משתנה מסוג 
`const` 
בזמן הגדרתו, כפי שרואים בדוגמה הבאה:

<div dir="ltr">

```js
// הגדרה תקינה
const maxItems = 30;

// Syntax error: missing initialization
const name;
```

</div>

המשתנה 
`maxItems` 
מאותחל בעת הגדרתו, לכן הקוד יעבוד ללא שגיאה. 
לעומת זאת, המשתנה
`name`
יזרוק שגיאת תחביר בעת הרצתו מאחר והמשתנה 
`name`
אינו מאותחל

#### הבדלים בין let ו const

משתנים מסוג
`const`
בדומה למשתנים מסוג 
`let` 
הם משתנים המוגדרים בסביבת בלוק של קוד. המשמעות היא שמשתנים קבועים לא נגישים ברגע שהקוד שרץ יוצא מתחומי הבלוק שבו הוגדרו. בנוסף לכך משתנים קבועים אינם ״מורמים״ כפי שרואים בדוגמה הבאה:

<div dir="ltr">

```js
if (condition) {
    const maxItems = 5;

    // קוד נוסף
}

// maxItems אינו נגיש
```

</div>

בדוגמת הקוד שראינו המשתנה הקבוע מוגדר בתוך בלוק של 
`if`. 
ברגע שהקוד בתוך אותו בלוק מסיים לרוץ המשתנה 
`maxItems` 
אינו נגיש יותר, כיוון שהוא אינו קיים מחוץ לבלוק שבו הוגדר. 

בדומה למשתנה מסוג 
`let`, 
משתנה מסוג 
`const` 
זורק שגיאה כאשר מנסים להשתמש בו עבור שם משתנה שכבר הוגדר באותה סביבה. 
אין זה משנה גם אם המשתנה הוגדר באמצעות 
`var` 
(עבור סביבה גלובלית או סביבת פונקציה) 
או באמצעות 
`let` 
(בתוך סביבת בלוק של קוד). 

לדוגמה:

<div dir="ltr">

```js
var message = "שלום!";
let age = 25;

// כל אחת מהשורות למטה תזרוק שגיאה
const message = "להתראות!";
const age = 30;
```

</div>

שתי ההגדרות מסוג
`const` 
בדוגמה למעלה יהיו תקינות במצב רגיל, אך בגלל הגדרות מסוג
`var` 
ו-
`let` 
שקדמו להן, אף אחת לא תעבוד.

למרות הדמיון הרב יש הבדל מובהק בין הגדרת 
`let` 
לבין הגדרת
`const`. 
כל ניסיון לבצע השמת ערך חדש למשתנה מסוג 
`const` 
יזרוק שגיאה, 
בין אם מדובר במצב ״קפדני״  
(strict mode)
או לא:

<div dir="ltr">

```js
const maxItems = 5;

maxItems = 6;      // שגיאה
```

</div>

בדומה למשתנים קבועים בשפות תכנות אחרות, המשתנה 
`maxItems` 
לא יכול לקבל ערך חדש מאוחר יותר. 
יחד עם זאת, בניגוד לשפות אחרות, במידה והערך הינו אוביקט ג׳אווהסקריפט אז הוא ניתן לשינוי.

#### הגדרת אובייקט באמצעות משתנה קבוע

הגדרת משתנה מסוג 
`const` 
מונעת שינוי של הקישור אך לא של הערך עצמו. משמעות הדבר היא שהגדרת משתנה מסוג 
 `const` 
 עבור אוביקט לא מונעת שינוי של אותו אוביקט. לדוגמה:

<div dir="ltr">

```js
const person = {
    name: "ניקולאס"
};

// תקין
person.name = "גרג";

// שגיאה
person = {
    name: "גרג"
};
```

</div>

בדוגמה הקודמת, הקישור עבור 
`person` 
נוצר עם הערך התחלתי של אוביקט בעל תכונה אחת. 
ניתן לשנות את הערך עבור
`person.name` 
מבלי שתיזרק שגיאה מאחר והדבר משנה רק את התוכן של 
`person` 
ולא משנה את הערך ש
`person` 
קשור אליו. 

כאשר מנסים לתת ערך חדש למשתנה 
`person` 
(ועל ידי כך לשנות את הקישור), 
תיזרק שגיאה. 

קל להתבלבל מהתנהגות זו ולכן יש לזכור את העקרון הבא:
שימוש ב- 
`const` 
מונע שינוי של הקישור לערך, אך אינו מונע שינוי של הערך עצמו.

### האזור המת הזמני - The Temporal Dead Zone

לא ניתן להשתמש במשתנה שהוגדר באמצעות
`let` 
או
`const` 
עד לאחר שהוגדר. ניסיון להשתמש במשתנה לפני כן זורק שגיאת ייחוס 
(ReferenceError), 
השגיאה נזרקת גם אם משתמשים בפעולות בטוחות יחסית כמו פעולת 
`typeof` 
בדוגמה הבאה:

<div dir="ltr">

```js
if (condition) {
    console.log(typeof value);  // ReferenceError!
    let value = "כחול";
}
```

</div>

בדוגמה זו, המשתנה בשם 
`value` 
מוגדר ומאותחל באמצעות הגדרת 
`let`
אך קודם לכן נזרקת שגיאה בגלל שורת הקוד הקודמת. הבעיה היא שהמשתנה 
`value` 
נמצא בתוך מה שקהילת המפתחים כינתה בשם 
*האזור המת הזמני* 
(TDZ). 

השם
TDZ 
אינו מופיע באופן מפורש באפיון אקמהסקריפט אך המונח משמש כדי לתאר מדוע הגדרות מסוג 
`let` 
ו- 
`const`
אינן נגישות לפני הגדרתן. בהמשך נעבור על מספר דקויות שלהן גורם ה 
TDZ 
ולמרות שהדוגמאות משתמשות במשתנה מסוג 
`let`,
חשוב לדעת שהמידע משמש גם עבור משתנה מסוג 
`const`

כאשר מנוע ריצה של ג׳אווהסקריפט מסתכל בתוך בלוק של קוד ומוצא הגדרת משתנה, אזי הוא מרים את ההגדרה לתחילת הפונקציה או לתחילת הסביבה הגלובלית
(עבור משתנה מסוג
 `var`)
או שאותו מנוע ריצה ממקם את ההגדרה בתוך ה-
TDZ 
(עבור משתנים מסוג 
`let` ו `const`). 
כל ניסיון לגשת למשתנה בתוך ה 
TDZ 
יגרום לזריקת שגיאה בזמן ריצה.

אותו משתנה מסולק מתוך ה
TDZ 
וכך הופך בטוח לשימוש, 
רק כאשר הקוד מגיע לשורת הקוד בה מוגדר המשתנה.

אותה התנהגות מתקיימת בכל ניסיון לגשת למשתנה מסוג 
`let` או `const` 
טרם הגדרתו. כפי שמדגימה הדוגמה הקודמת, הדבר תקף גם עבור האופרטור 
`typeof` 
שנחשב לבטוח לשימוש. 
יחד עם זאת ניתן להשתמש ב
 `typeof` 
 על משתנה שקיים מחוץ לבלוק בו מוגדר המשתנה, אך לא בטוח שיתקבלו אותן התוצאות :.

<div dir="ltr">

```js
console.log(typeof value);     // "undefined"

if (condition) {
    let value = "כחול";
}
```

</div>


המשתנה
`value` 
אינו נמצא בתוך 
TDZ 
בזמן שאופרטור 
`typeof` 
פועל מאחר והאופרציה מתבצעת מבחוץ לבלוק הקוד שבתוכו מוגדר המשתנה 
`value`. 
משמעות הדבר היא שכלל לא קיים קישור עבור 
`value` 
ולכן פעולת 
`typeof` 
תסתיים עם הערך
`"undefined"`.

ה-
TDZ 
מהווה רק היבט ייחודי אחד של קשירות לסביבת בלוק. 
היבט ייחודי אחר מתבטא בעת השימוש בלולאות

## קישור משתנים בסביבת בלוק בתוך לולאות

אחד המקומות הטובים ביותר עבור משתנים ברמת בלוק הוא בתוך לולאות 
`for`, 
היכן שמשתנה אינדקס נועד לשימוש רק בתוך הלולאה. ראה דוגמה : 

<div dir="ltr">

```js
for (var i = 0; i < 10; i++) {
    process(items[i]);
}

// המשתנה i נגיש
console.log(i);                     // 10
```

</div>


בשפות אחרות היכן ששיוך ברמת בלוק קורה כברירת מחדל, הדוגמה האחרונה תעבוד כך שהמשתנה
`i` 
נגיש אך ורק בתוך לולאת ה 
`for`. 
לעומת זאת, בג׳אווהסקריפט המשתנה 
`i` 
עדיין נגיש לאחר שהלולאה סיימה לרוץ מאחר והגדרת ה 
`var` 
מורמת. 
באמצעות שימוש בהגדרת 
`let` 
תתקבל התוצאה הרצויה, כפי שמודגם בהמשך:

<div dir="ltr">

```js
for (let i = 0; i < 10; i++) {
    process(items[i]);
}

// המשתנה i אינו נגיש - תיזרק שגיאה
console.log(i);
```

</div>

בדוגמה זו, המשתנה 
`i` 
קיים אך ורק בתוך לולאת ה 
`for`. 
ברגע שהלולאה סיימה לרוץ המשתנה אינו נגיש. 

### פונקציות בתוך לולאות

מאז ומתמיד משתנים מסוג
`var`
היו בעייתיים מבחינת הגדרת פונקציות בתוך לולאות, מאחר ומשתנים שנוצרו בלולאה עדיין נגישים מחוצה לה. 
לדוגמה:

<div dir="ltr">

```js
var funcs = [];

for (var i = 0; i < 10; i++) {
    funcs.push(function() { console.log(i); });
}

funcs.forEach(function(func) {
    func();     // המספר ״10״ יודפס עשר פעמים
});
```

</div>

ייתכן ותטעו לחשוב שהקוד הנ״ל ידפיס את הספרות 0-9 אך במקום זאת הוא ידפיס את המספר 10 עשר פעמים רצופות.
הסיבה היא שהמשתנה 
`i` 
קיים באופן משותף עבור כל איטרציה של הלולאה, והמשמעות היא שפונקציות שנוצרו בתוך הלולאה מתייחסות לאותו משתנה. 
המשתנה 
`i` 
מקבל את הערך 
 `10` 
 לאחר שהלולאה מסתיימת, וכאשר קוראים ל
`console.log(i)` 
זה יהיה הערך שיודפס. 

כדי לטפל בבעיה זו נהוג להשתמש בפונקציה שנקראת באופן מיידי
(IIFEs - immediately-invoked function expressions)
בתוך לולאות על מנת ליצור עותק מקומי לפונקציה.
לדוגמה:
<div dir="ltr">

```js
var funcs = [];

for (var i = 0; i < 10; i++) {
    funcs.push((function(value) {
        return function() {
            console.log(value);
        }
    }(i)));
}

funcs.forEach(function(func) {
    func();     // מדפיס את הספרות 0-9
});
```

</div>

בדוגמה זו משתמשים ב 
(IIFE) 
בתוך הלולאה.

המשתנה 
`i` 
מועבר לתוך ה 
IIFE 
אשר יוצרת עותק מקומי משלה ושומרת אותו בתור המשתנה בשם 
`value`. 
זהו הערך שישמש בתוך הפונקציה, עבור אותה איטרציה, וכך הקריאה לכל פונקציה מדפיסה את הערך לו מצפים, ספירה מ 0 ועד 9. 

למרבה המזל, שיוך לבלוק באמצעות משתנים מסוג 
`let` ו `const` 
עושים זאת באופן פשוט וקל. 

### הגדרת let בתוך לולאה

הגדרת 
`let` 
מפשטת שימוש בלולאות על ידי מתן אותה תוצאה כמו השימוש ב 
IIFE 
בדוגמה הקודמת. 

בכל איטרציה, הלולאה יוצרת משתנה חדש ומאתחלת אותו לערך של המשתנה בעל אותו השם מהאיטרציה האחרונה של הלולאה. 
בצורה זו אין יותר צורך להשתמש ב
IIFE 
על מנת לקבל את התוצאה הרצויה.

לדוגמה:
<div dir="ltr">

```js
var funcs = [];

for (let i = 0; i < 10; i++) {
    funcs.push(function() {
        console.log(i);
    });
}

funcs.forEach(function(func) {
    func();     // יודפס 0 ואז 1 ואז 2 עד שמגיעים ל 9
})
```

</div>

לולאה כמו בדוגמה האחרונה פועלת באותה צורה כמו הלולאה בדוגמה שלפניה שהשתמשה במשתנה מסוג 
`var` 
ביחד עם 
IIFE, 
אך היא קריאה וקצרה יותר. 
השימוש במשתנה מסוג 
`let` 
יוצר משתנה חדש בשם 
`i` 
בכל איטרציה של הלולאה, ולכן כל פונקציה שמוגדרת בתוך הלולאה מקבלת עותק מקומי של המשתנה 
`i`. 
לכל עותק של 
`i` 
ניתן הערך שהתקבל בתחילת האיטרציה שבה נוצר. 
הדבר נכון גם עבור לולאות מסוג 
`for-in` ו `for-of`
כפי שניתן לראות בדוגמה הבאה:

<div dir="ltr">

```js
var funcs = [],
    object = {
        a: true,
        b: true,
        c: true
    };

for (let key in object) {
    funcs.push(function() {
        console.log(key);
    });
}

funcs.forEach(function(func) {
    func();     // יודפס "a", ואז "b", ואז "c"
});
```

</div>

בדוגמה זו לולאה 
`for-in` 
פועלת באותה צורה כמו לולאת
`for`. 
בכל איטרציה של הלולאה נוצר שיוך חדש 
(binding) 
של המשתנה 
`key` 
ולכן כל פונקציה מקבלת עותק מקומי משלה עבור המשתנה 
`key`. 
כתוצאה מכך כל פונקציה מדפיסה ערך שונה. 
לו היינו משתמשים במשתנה מסוג 
`var` 
במקום משתנה מסוג 
`let`
אזי כל הפונקציות היו מדפיסות 
`"c"`.

I> חשוב
לדעת שההתנהגות של משתנים מסוג 
`let` 
בתוך לולאות היא התנהגות שאופיינה בצורה ברורה בשפה עצמה 
ואינה בהכרח קשורה למאפייני הגדרת
`let` 
כמשתנה שאינו מורם. למעשה, מימושים מוקדמים פעלו ללא התנהגות זו והיא התווספה רק בשלב מאוחר יותר.

### הגדרת משתנים קבועים בתוך לולאות

המהדורה השישית של אקמהסקריפט אינה אוסרת שימוש בהגדרת 
`const` 
בתוך לולאות. אך קיימת התנהגות שונה בהתאם לסוג הלולאה.

עבור לולאת 
`for` 
רגילה, ניתן להשתמש במשתנה מסוג 
`const` 
עבור החלק המאתחל של הלולאה, אך הלולאה תזרוק שגיאה במידה ומנסים לשנות את הערך. 
לדוגמה: 

<div dir="ltr">

```js
var funcs = [];

// שגיאה לאחר האיטרציה הראשונה
for (const i = 0; i < 10; i++) {
    funcs.push(function() {
        console.log(i);
    });
}
```

</div>

בדוגמת הקוד האחרונה, המשתנה 
`i` 
מוגדר בתור משתנה קבוע. 
האיטרציה הראשונה של הלולאה, היכן שערכו של המשתנה 
`i`
אותחל ל 0 
תרוץ בהצלחה. 
אולם, תיזרק שגיאה כאשר הקוד 
`i++` 
ירוץ מאחר והקוד הנ״ל מנסה לשנות ערך קבוע. 
לכן ניתן להשתמש בהגדרת 
`const` 

בניגוד לכך, כאשר משתמשים בו בלולאות מסוג
`for-in` או `for-of` 
משתנה מסוג 
`const`
מתנהג בדיוק כמו משתנה מסוג 
`let`. 
לכן דוגמה הקוד הבאה תרוץ בהצלחה

<div dir="ltr">

```js
var funcs = [],
    object = {
        a: true,
        b: true,
        c: true
    };

// אין שגיאה
for (const key in object) {
    funcs.push(function() {
        console.log(key);
    });
}

funcs.forEach(function(func) {
    func();     // יודפס "a", ואז "b", ואז "c"
});
```

</div>

דוגמה הקוד האחרונה מתנהגת כמו הדוגמה השניה בפסקה
"הגדרת let בתוך לולאה". 
ההבדל היחיד הוא שהערך של המשתנה 
`key` 
אינו ניתן לשינוי בתוך הלולאה.
לולאות מסוג 
`for-in` או `for-of` 
עובדות בצורה כזו בשילוב עם הגדרות 
`const`
מאחר ומאתחל הלולאה יוצר שיוך חדש בכל איטרציה ולא מנסה לשנות את הערך של שיוך קיים 
(כפי שקרה בדוגמה הקודמת כאשר ניסינו לעשות זאת בתוך לולאה מסוג לולאת `for`).

## שיוך לסביבת בלוק גלובלית

הבדל נוסף בין משתנים מסוג 
`let` ו `const` 
לבין משתנים מסוג 
`var` 
הוא התנהגותם בסביבה הגלובלית. 
כאשר משתנים מסוג 
`var` 
מוגדרים בסביבה הגלובלית, הדבר יוצר משתנה גלובלי חדש, 
שהופך למפתח של האובייקט הגלובלי 
(`window` בדפדפנים). 
בצורה כזו ניתן בטעות לדרוס ערך גלובלי קיים, 
לדוגמה: 

<div dir="ltr">

```js
// בדפדפן
var RegExp = "Hello!";
console.log(window.RegExp);     // "Hello!"

var ncz = "Hi!";
console.log(window.ncz);        // "Hi!"
```

</div>

למרות שהמשתנה הגלובלי 
`RegExp` 
מוגדר כחלק של  
`window` 
אין לו חסינות מפני דריסה על ידי משתנה מסוג 
`var`. 
הדוגמה הנ״ל מגדירה משתנה גלובלי חדש בשם 
`RegExp` 
אשר דורסת את המשתנה המקורי. 
בצורה דומה, 
המשתנה 
`ncz` 
מוגדר כמשתנה בסביבה הגלובלית ומייד מגדיר מפתח חדש באוביקט 
`window`. 
זוהי הדרך שבה 
JavaScript 
למן ההתחלה.

אילו היינו משתמשים במשתנים מסוג 
`let` או `const`
בסביבה הגלובלית,
היינו יוצרים שיוך חדש בסביבה הגלובלית אך לא היה מתווסף מפתח חדש לאוביקט הגלובלי. 
משמעות הדבר היא שלא ניתן לדרוס משתנה גלובלי על ידי הגדרת 
`let` או `const`, 
ניתן רק להסתיר אותו. 

לדוגמה:

<div dir="ltr">

```js
// בדפדפן
let RegExp = "Hello!";
console.log(RegExp);                    // "Hello!"
console.log(window.RegExp === RegExp);  // false

const ncz = "Hi!";
console.log(ncz);                       // "Hi!"
console.log("ncz" in window);           // false
```

</div>

בדוגמה זו, 
משתנה חדש מסוג 
`let` 
מוגדר תחת השם  
`RegExp` 
ובתורו מסתיר את משתנה 
`RegExp` 
שכבר קיים בסביבה הגלובלית.

משמעות הדבר הינה שהערכים עבור 
`window.RegExp` ו `RegExp` 
שונים זה מזה, כך שאין דריסה של משתנים בסביבה הגלובלית. 
כמו כן, הגדרת 
`const`
עבור המשתנה בשם
`ncz` 
יוצרת שיוך עבור משתנה בסביבה הגלובלית אך אינה יוצרת מפתח חדש באוביקט הגלובלי. 
תכונה זו של משתנים מסוג
`let` ו `const` 
הופכת אותם לבטוחים יותר לשימוש בסביבה הגלובלית כאשר אין זה רצוי ליצור מפתחות חדשים באוביקט הגלובלי.

I> ניתן עדיין להשתמש בהגדרה מסוג
`var` 
בסביבה הגלובלית עבור קוד שרוצים לאפשר את הגישה אליו מתוך האוביקט הגלובלי. 
זהו דבר נפוץ בסביבת הדפדפן כאשר ברצונך לשתף קוד בין פריימים או חלונות נפרדים. 

## דרכים מומלצות לשימוש בשיוך משתנים בסביבת בלוק

בעת שהמהדורה השישית הייתה בפיתוח, היו רבים שהאמינו שיש להשתמש בהגדרת
`let` 
בתור הגדרת ברירת מחדל במקום להשתמש בהגדרות מסוג
`var`. 
עבור מפתחי ג׳אווהסקריפט רבים, 
הגדרות 
`let`
פועלות כמו שהם האמינו שהגדרות מסוג 
`var` 
היו צריכות לפעול מלכתחילה, 
לכן החלפה ישירה בין הסוגים היא הגיונית. 
במקרים אלו, השימוש בהגדרות 
`const` 
ייעשה עבור משתנים שצריכים להיות מוגנים בפני שינוי

ואולם, עם הזמן התפתחה גישה חלופית:
יש להשתמש בהגדרות מסוג 
`const` 
בתור ברירת מחדל ויש להשתמש בהגדרות מסוג 
`let` 
כאשר ידוע מראש כי ערך המשתנה עתיד להשתנות. 
הרציונל לכך הוא שרוב המשתנים לא משנים את ערכם לאחר האתחול מאחר ושינויי ערך שאינם צפויים הם מקור לבאגים.

## סיכום

הגדרות משתנים עבור סביבת בלוק מסוג 
`let` ו `const` 
מביאות איתן מה שנקרא שיוך לקסיקאלי לג׳אווהסקריפט. 
הגדרות אלו אינן מורמות וקיימות רק עבור אותו הבלוק בקוד בו הוגדרו. 
דבר זה מייצר התנהגות שדומה יותר לשפות קיימות אחרות, ופחות נוטה ליצירת שגיאות לא מכוונות, מאחר ומשתנים יכולים כעת להיות מוגדרים בדיוק היכן שמשתמשים בהם. 
כתופעת לוואי לכך, לא ניתן לגשת למשתנים לפני שהם מוגדרים בפועל, אפילו לא באמצעות אופרטורים שנחשבים בטוחים לשימוש כגון אופרטור 
`typeof`. 
ניסיון לגשת למשתנה עבור סביבת בלוק לפני הגדרתו זורק שגיאה עקב שיוך המשתנה במה שנקרה 
האזור המת הזמני 
(TDZ). 

במקרים רבים,
משתנים מסוג
`let` ו `const` 
מתנהגים באופן דומה למשתנים מסוג 
`var`. 
הדבר אינו נכון עבור לולאות.
השימוש במשתנים מסוג 
`let` ו `const` 
בתוך לולאות
`for-in` ו `for-of` 
יוצר שיוך חדש עבור כל איטרציה של הלולאה. 
משמעות הדבר היא שפונקציות אשר מוגדרות בתוך הלולאה יכולות לגשת למשתנים ולערכם כפי שהיה בעת האיטרציה הנוכחית, 
ולא כפי שהם לאחר שהלולאה סיימה לעבוד 
(ההתנהגות הקיימת עבור משתנים מסוג `var`). 
הדבר נכון גם עבור הגדרת משתנים מסוג 
`let`
בתוך לולאות מסוג לולאות, 
`for`
בעוד שניסיון להשתמש בהגדרת
`const`
בתוך לולאת
`for`
עלול לזרוק שגיאה.

הדרך המומלצת לשימוש במשתנים עבור סביבת בלוק הינה  
להשתמש בהגדרת 
`const`
כברירת מחדל ולהעדיף שימוש בהגדרת
`let`
כאשר ידוע לך שהמשתנה עתיד לקבל ערך שונה. 
דרך זו מבטיחה רמה בסיסית של 
קוד מוגן כנגד שינויים בלתי צפויים
שיכול למנוע שגיאות מסויימות.
</div>