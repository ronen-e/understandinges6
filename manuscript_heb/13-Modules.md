<div dir="rtl">

# עטיפת קוד במודולים

גישת ה ״שיתוף הכל״ של
ג׳אווהסקריפט
לטעינת קוד היא אחד מההיבטים המועדים לשגיאה והמבלבלים ביותר של השפה. שפות אחרות משתמשות במושגים כמו חבילות / פקג׳ס
(packages)
כדי להגדיר את היקף הקוד, אך עד
ECMAScript 6,
כל מה שהוגדר בכל קובץ ג׳אווהסקריפט של אפליקציה שיתף מרחב/סקופ גלובלי אחד. כאשר אפליקציות ווב הפכו מורכבות יותר והחלו להשתמש עוד יותר בג׳אווהסקריפט, גישה זו גרמה לבעיות שונות כמו: התנגשוות בין שמות ובעיות אבטחה. מטרה אחת של
ECMAScript 6
הייתה לפתור את בעיית הסקופ ולהכניס קצת סדר ליישומי ג׳אווהסקריפט. לשם כך נוצרו מודולים.

## מה זה מודולים?

*מודולים*
הם קבצי
ג׳אווהסקריפט
הנטענים במצב שונה
(בניגוד ל *סקריפטים*, הנטענים באופן הרגיל).
מצב שונה זה הכרחי מכיוון שלמודולים יש סמנטיקה שונה מאוד מאשר סקריפטים:

1. קוד המודול פועל באופן אוטומטי במצב קפדני
(strict mode),
ואין דרך לבטלו
1. משתנים שנוצרו ברמה העליונה של מודול אינם מתווספים אוטומטית לסקופ הגלובלי המשותף. הם קיימים רק בסקופ העליון של המודול.
1. הערך של
`this`
ברמה העליונה של המודול הוא
`undefined`.
1. מודולים אינם מאפשרים הערות בסגנון
HTML
בקוד
(מאפיין שנותר עוד מימיו המוקדמים של הדפדפן).
1. על המודולים לייצא כל מה שאמור להיות זמין לקוד מחוץ למודול.
1. מודולים רשאים לייבא ממודולים אחרים.

הבדלים אלה עשויים להיראות קטנים במבט ראשון, אך הם מייצגים שינוי משמעותי באופן טעינת קוד ג׳אווהסקריפט
והרצתו, עליו יורחב במהלך פרק זה. הכוח האמיתי של המודולים הוא היכולת לייצא ולייבא רק חלקים שאנו זקוקים להם, ולא כל מה שיש בקובץ. הבנה טובה של ייצוא וייבוא הינה יסודית להבנת האופן שבו מודולים שונים מסקריפטים.

## ייצוא בסיסי

ניתן להשתמש במילת המפתח
`export`
כדי לחשוף חלקים מהקוד למודולים אחרים. במקרה הפשוט ביותר, ניתן להציב
`export`
לפני כל הגדרת משתנה, פונקציה או מחלקה כדי לייצא אותו מהמודול, כך:

<div dir="ltr">

```js
// export data
export var color = "אדום";
export let name = "ניקולאס";
export const magicNumber = 7;

// export function
export function sum(num1, num2) {
  return num1 + num1;
}

// export class
export class Rectangle {
  constructor(length, width) {
    this.length = length;
    this.width = width;
  }
}

// this function is private to the module
function subtract(num1, num2) {
  return num1 - num2;
}

// define a function...
function multiply(num1, num2) {
  return num1 * num2;
}

// ...and then export it later
export { multiply };
```

</div>

יש לשים לב בדוגמא זו לכמה דברים. ראשית, מלבד מילת המפתח
`export`,
כל הצהרה זהה לחלוטין להצהרה בדרך הרגילה. לכל פונקציה או מחלקה מיוצאת יש גם שם;
הסיבה לכך היא שהייצוא של פונקציות והצהרות מחלקה דורשות שם. לא ניתן לייצא פונקציות או מחלקות אנונימיות באמצעות תחביר זה אלא אם כן משתמשים במילה
`default`
(
נדון בפירוט בסעיף
"ערכי ברירת מחדל במודולים"
).

בקוד מופיעה הפונקציה
<span dir="ltr">`multiply()`</span>,
שאינה מיוצאת כאשר היא מוגדרת.
זה קוד תקין כי לא חובה לייצא הצהרה:
ניתןגם לייצא הפניות/רפרנס. לבסוף, שימול לב לכך שדוגמה זו אינה מייצאת את הפונקציה
<span dir="ltr">`subtract()`</span>.
פונקציה זו לא תהיה נגישה מחוץ למודול זה מכיוון שמשתנים, פונקציות או מחלקות שלא מיוצאים במפורש נשארים פרטיים למודול.

## ייבוא בסיסי

ברגע שיש לך מודול שמייצא קוד, ניתן לגשת לפונקציונליות במודול אחר באמצעות מילת המפתח
`import`.
שני החלקים של משפט
`import`
הם המזהים שאנו מייבאים והמודול ממנו יש לייבא מזהים אלה.
זו הצורה הבסיסית של ההצהרה:

<div dir="ltr">

```js
import { identifier1, identifier2 } from "./example.js";
```

</div>

הסוגריים המסולסלות לאחר
`import`
מציינות את המזהים לייבוא ממודול נתון.
מילת המפתח
`from`
מציינת את המודול שממנו ניתן לייבא את המזהה הנתון. המודול מוגדר על ידי מחרוזת המייצגת את הנתיב למודול
(
הנקרא
<span dir="ltr">*module specifier*</span>
).
הדפדפנים משתמשים באותו פורמט נתיב שניתן להעביר לאלמנט
`<script>`,
כלומר יש לכלול סיומת קובץ. לעומת זאת,
Node.js
עוקב אחר המוסכמה המסורתית שלה להבדיל בין קבצים וחבילות מקומיים בהתבסס על קידומת מערכת קבצים. לדוגמה,
`example`
תהיה פקג׳ ו-
<span dir="ltr">`./example.js`</span>
תהיה קובץ מקומי.

I> רשימת החלקים לייבוא נראית דומה לאובייקט , אך אין מדובר באובייקט.

בעת ייבוא מזהה ממודול, הקוד פועל כאילו הוגדר באמצעות
`const`.
כלומר, לא ניתן להגדיר משתנה אחר בעל אותו שם
(כולל ייבוא מזהה אחר באותו שם),
להשתמש במזהה לפני משפט
`import`
או לשנות את ערכו.

### ייבוא מזהה בודד

נניח שהדוגמה הראשונה בסעיף "ייצוא בסיסי" היא במודול עם שם הקובץ
`example.js`.
ניתן לייבא ולהשתמש בחלקים מאותו מודול במספר דרכים. למשל, ניתן פשוט לייבא מזהה אחד:

<div dir="ltr">


```js
// ייבוא בודד
import { sum } from "./example.js";

console.log(sum(1, 2)); // 3

sum = 1; // שגיאה
```

</div>

למרות ש-
`example.js`
מייצאת יותר מפונקציה אחת בלבד, דוגמה זו מייבאת רק את הפונקציה
<span dir="ltr">`sum()`</span>.
אם ננסה להקצות ערך חדש ל
`sum`,
התוצאה היא שגיאה, מכיוון שלא ניתן להקצות ערך חדש לחלקים מיובאים.

W> הקפידו לכלול את
<span dir="ltr">`/`, `./`,</span>
או
<span dir="ltr">`../`</span>
בתחילת הקובץ שמייבאים לצורך התאמה טובה ביותר בין דפדפנים ו-
Node.js.

### ייבוא חלקי קוד מרובים

אם תרצו לייבא חלקים מרובים ממודול תוכלו לפרט אותן באופן מפורש כדלקמן:

<div dir="ltr">

```js
// ייבוא של מספר מזהים
import { sum, multiply, magicNumber } from "./example.js";
console.log(sum(1, magicNumber)); // 8
console.log(multiply(1, 2)); // 2
```

</div>

בדוגמה זו מיובאים שלושה חלקי קוד מהמודול:
`sum`, `multiply`
ו
`magicNumber`.
לאחר מכן הם משמשים כאילו הם הוגדרו באופן מקומי.

### ייבוא כל המודול

יש גם מקרה מיוחד המאפשר לנו לייבא את כל המודול כאובייקט יחיד. כל החלקים המיוצאים זמינים אז כתכונות על האובייקט. לדוגמה:

<div dir="ltr">

```js
// ייבוא הכל
import * as example from "./example.js";
console.log(example.sum(1, example.magicNumber)); // 8
console.log(example.multiply(1, 2)); // 2
```

</div>

בקוד זה, כל החלקים המיוצאים ב-
`example.js`
נטענים לאובייקט שנקרא
`example`.
לאחר מכן כל החלקים המיוצאים
(
פונקציית
<span dir="ltr">`sum()`</span>,
פונקציית
<span dir="ltr">`multiple()`</span>
ו-
`magicNumber`
)
זמינים לשימוש כתכונות באובייקט
`example`.
פורמט ייבוא זה נקרא ייבוא
*ניימספייס*
/
*מרחב שמות*
( *namespace import* )
מכיוון שהאובייקט
`example`
אינו קיים בתוך הקובץ
`example.js`.
במקום זה הוא נוצר כדי לשמש כאובייקט ניימספייס עבור כל החלקים המיוצאים של
`example.js`.

זכרו, שלא משנה כמה פעמים נעשה שימוש במודול בהצהרות
`import` ,
המודול ירוץ רק פעם אחת. לאחר הרצת וייבוא המודול, המודול נשמר בזיכרון ומשמש אותנו מחדש בכל פעם שמשפט אחר של
`import`
מפנה אליו. הסתכלו בדוגמה הבאה:

<div dir="ltr">

```js
import { sum } from "./example.js";
import { multiply } from "./example.js";
import { magicNumber } from "./example.js";
```

</div>

למרות שישנן שלוש הצהרות
`import`
במודול זה,
`example.js`
יבוצע רק פעם אחת. אם מודולים אחרים באותו יישום היו מייבאים חלקים מ-
`example.js`,
מודולים אלה ישתמשו באותו מופע מודול בו משתמש הקוד בדוגמה.

### מגבלות תחביר המודול

מגבלה חשובה הן של
`export`
והן של
`import`
היא שחובה להשתמש בהם מחוץ להצהרות ופונקציות. למשל, קוד זה יזרוק שגיאת תחביר:

<div dir="ltr">

```js
if (flag) { export flag; } // שגיאת תחביר
```

</div>

הצהרת
`export`
נמצאת בתוך הצהרת
`if`,
דבר שאינו תקין.
היצוא לא יכול להיות מותנה או להתבצע באופן דינמי בשום צורה שהיא.
אחת הסיבות לקיומו של תחביר כתיבת מודולים היא לאפשר למנוע
ג׳אווהסקריפט
לקבוע באופן סטטי מה מיוצא. ככזה, ניתן  להשתמש בפקודת
`export`
רק ברמה העליונה של המודול.

באופן דומה, לא ניתן להשתמש בפקודת
`import`
בתוך הצהרה;
ניתן להשתמש בו רק ברמה העליונה.
כלומר, קוד זה גם הוא זורק שגיאת תחביר:

<div dir="ltr">

```js
function tryImport() {
  // syntax error
  import flag from "./example.js";
}
```

</div>

לא ניתן לייבא חלקים בצורה דינמית מאותה סיבה שלא ניתן לייצא חלקים בצורה דינמית. מילות המפתח
`export`
ו
`import`
נועדו להיות סטטיות כך שכלים כמו עורכי טקסט יוכלו לדעת בקלות איזה מידע זמין ממודול.

### שינוי חלקים מיובאים

הצהרות
`import`
של
ECMAScript 6
יוצרות אפשרות קריאה בלבד למשתנים, פונקציות ומחלקות במקום להצביע לקוד כמו למשתנים רגילים. למרות שהמודול שמייבא את הקוד לא יכול לשנות את ערכו, המודול שמייצא את המזהה יכול. לדוגמה, נניח שתרצה להשתמש במודול זה:

<div dir="ltr">

```js
export var name = "ניקולאס";
export function setName(newName) {
  name = newName;
}
```

</div>

כאשר אתה מייבא את שתי הפונקציות האלה, הפונקציה
<span dir="ltr">`setName()`</span>
יכולה לשנות את הערך של
`name`:

<div dir="ltr">

```js
import { name, setName } from "./example.js";

console.log(name); // "ניקולאס"
setName("גרג");
console.log(name); // "גרג"

name = "Nicholas";  // שגיאה
```

</div>

הקריאה לפונקציה
<span dir="ltr">`setName("Greg")`</span>
חוזרת למודול שממנו מיוצא
<span dir="ltr">`setName()`</span>
ומבוצעת שם, ומגדירה את
`name`
ל
`"Greg"`.
שימו לב ששינוי זה משתקף אוטומטית בחלק
`name`
המיובא. הסיבה לכך היא ש
`name`
הוא השם המקומי למזהה
`name`
המיוצא.
`name`
המשמש בקוד לעיל וה
`name`
המשמש במודול המיובא ממנו אינם זהים.

## שינוי השם לחלקים מיובאים ומיוצאים

ייתכןולא נרצה להשתמש בשם המקורי של משתנה, פונקציה או מחלקה שמיובאים ממודול. למרבה המזל, ניתן לשנות את שם היצוא גם במהלך הייצוא וגם במהלך הייבוא.

במקרה הראשון, נניח שיש לך פונקציה שברצונך לייצא בשם אחר. ניתן להשתמש במילת המפתח
`as`
כדי לציין את השם של הפונקציה מחוץ למודול:

<div dir="ltr">

```js
function sum(num1, num2) {
  return num1 + num2;
}

export { sum as add };
```

</div>

כאן, הפונקציה
<span dir="ltr">`sum()`</span>
(
`sum`
הוא
*השם המקומי* -
<span dir="ltr">*local name*</span>
)
מיוצאת כ-
<span dir="ltr">`add()`</span>
(
`add`
הוא
*השם המיוצא* -
<span dir="ltr">*exported name*</span>
).
פירוש הדבר שכאשר מודול אחר מעוניין לייבא פונקציה זו,
יהיה עליו להשתמש בשם
`add`
במקום זאת:

<div dir="ltr">

```js
import { add } from "./example.js";
```

</div>

אם המודול שמייבא את הפונקציה רוצה להשתמש בשם אחר, הוא יכול גם להשתמש ב
`as`:

<div dir="ltr">

```js
import { add as sum } from "./example.js";
console.log(typeof add); // "undefined"
console.log(sum(1, 2)); // 3
```

</div>

קוד זה מייבא את הפונקציה
<span dir="ltr">`add()`</span>
באמצעות
*השם המיובא* -
<span dir="ltr">`(*import name*)`</span>
ומשנה את שמו ל-
<span dir="ltr">`sum()`</span>
(השם המקומי).
פירוש הדבר שאין במודול זה מזהה בשם
`add`.

### ערך דיפולטיבי במודולים

תחביר המודול מותאם לייצוא וייבוא של ערך דיפולטיבי ממודולים, מכיוון שדפוס זה היה נפוץ למדי במערכות מודולים אחרות, כמו
CommonJS
(
פורמט מודול
ג׳אווהסקריפט
אחר, שהפך לפופולרי על ידי
Node.js
).
ערך ברירת המחדל
<span dir="ltr">(*default value*)</span>
עבור מודול הוא משתנה, פונקציה או מחלקה שצוינו על ידי מילת המפתח
`default`,
וניתן להגדיר רק יצוא ערך דיפולטיבי אחד לכל מודול. שימוש במילת המפתח
`default`
עם יצוא מרובה יגרום לשגיאת תחביר.

### ייצוא ערכי ברירת מחדל

הנה דוגמה פשוטה המשתמשת במילת המפתח
`default`:

<div dir="ltr">

```js
export default function (num1, num2) {
  return num1 + num2;
}
```

</div>

מודול זה מייצא פונקציה כערך ברירת המחדל שלה. מילת המפתח
`default`
מציינת שמדובר בייצוא ברירת מחדל. הפונקציה אינה דורשת שם מכיוון שהמודול עצמו מייצג את הפונקציה.

ניתן גם לציין מזהה כיצוא ברירת המחדל על ידי הצבתו לאחר
`export default`,
כגון:

<div dir="ltr">

```js
function sum(num1, num2) {
  return num1 + num2;
}

export default sum;
```

</div>

כאן, הפונקציה
<span dir="ltr">`sum()`</span>
מוגדרת תחילה ומאוחרת מיוצאת כערך ברירת המחדל של המודול.
ייתכן שתרצה לבחור בגישה זו אם יש לחשב את ערך ברירת המחדל.

דרך שלישית לציין מזהה כיצוא ברירת המחדל היא באמצעות תחביר שינוי שם כדלקמן:

<div dir="ltr">

```js
function sum(num1, num2) {
  return num1 + num2;
}

export { sum as default };
```

</div>

למזהה
`default`
יש משמעות מיוחדת בייצוא שמות מחדש ומציין שערך צריך להיות ברירת המחדל עבור המודול. מכיוון ש
`default`
היא מילת מפתח ב-
ג׳אווהסקריפט,
לא ניתן להשתמש בה לשם משתנה, פונקציה או שם מחלקה
(ניתן להשתמש בה כשם מאפיין).
אז השימוש ב
`default`
לשם שינוי יצוא הוא מקרה מיוחד ליצירת עקביות עם אופן ההגדרה של יצוא שאינו ברירת מחדל. תחביר זה שימושי אם ברצונך להשתמש במשפט
`default`
יחיד כדי לציין יצוא מרובים, כולל ברירת המחדל, בבת אחת.

### ייבוא ערכי ברירת מחדל

ניתן לייבא ערך ברירת מחדל ממודול באמצעות התחביר הבא:

<div dir="ltr">

```js
// ייבוא הערך הדיפולטיבי
import sum from "./example.js";

console.log(sum(1, 2)); // 3
```

</div>

הצהרת ייבוא זו מייבאת את הערך הדיפולטיבי מהמודול
`example.js`.
שים לב כי לא נעשה שימוש בסוגריים מסולתלים, בשונה ממה שהיינו רואים בייבוא רגיל. השם המקומי
`sum`
משמש לייצוג כל ערך דיפולטיבי שהמודול מייצא.
התחביר הזה הוא הנקי ביותר, ויוצרי
ECMAScript 6
מצפים שהוא יהיה צורת הייבוא הדומיננטית באינטרנט.

עבור מודולים המייצאים גם ערך דיפולטיבי וגם ערכים אחרים, ניתן לייבא את כל הקוד המיוצא בשורה אחת. לדוגמה, נניח שקיים המודול הבא:

<div dir="ltr">

```js
export let color = "אדום";

export default function (num1, num2) {
  return num1 + num2;
}
```

</div>

ניתן לייבא הן את
`color`
והן את הערך הדיפולטיבי באמצעות הצהרת
`import`
הבאה:

<div dir="ltr">

```js
import sum, { color } from "./example.js";

console.log(sum(1, 2)); // 3
console.log(color); // "אדום"
```

</div>

הפסיק מפריד בין הערך המוגדר כברירת מחדל לבין הערכים שאינם דיפולטיביים, המוקפים גם בסוגריים מסולסלים. חשוב לזכור שערך דיפולטיבי חייב לבוא לפני ערכים רגילים בהצהרת
`import`.

כמו בייצוא, ניתן לייבא ערך דיפולטיבי בעזרת התחביר המשנה את שם הערך:

<div dir="ltr">

```js
// מקביל לדוגמה הקודמת
import { default as sum, color } from "example";

console.log(sum(1, 2)); // 3
console.log(color); // "אדום"
```

</div>

בקוד זה, ייצוא ברירת המחדל
(`default`)
מקבל את השם
`sum`
וייצוא נוסף של
`color`
מיובא. דוגמא זו מקבילה לדוגמא הקודמת.

## ייצוא חוזר של קוד

יכול להיות שנרצה לייצא מחדש
<span dir="ltr">(re-export)</span>
ערך שהמודול שלנו ייבא (למשל, אם אנו יוצרים ספרייה מכמה מודולים קטנים). באפשרותנו לייצא מחדש ערך מיובא עם הדפוסים שכבר נדונו בפרק זה באופן הבא:

<div dir="ltr">

```js
import { sum } from "./example.js";
export { sum };
```

</div>

זה עובד, אבל הצהרה אחת יכולה גם לעשות את אותו הדבר:

<div dir="ltr">

```js
export { sum } from "./example.js";
```

</div>

צורה זו של
`export`
בודקת את המודול שצוין עבור ההצהרה על
`sum`
ואז מייצאת אותו. כמובן, ניתן גם לבחור לייצא שם אחר באותו ערך:

<div dir="ltr">

```js
export { sum as add } from "./example.js";
```

</div>

כאן,
`sum`
מיובא מ-
<span dir="ltr">`"./example.js"`</span>
ואז מיוצא כ
`add`.

אם נרצה לייצא הכל ממודול אחר, נוכל להשתמש בתבנית
`*`:

<div dir="ltr">

```js
export * from "./example.js";
```

</div>

כאשר אנו מייצאים הכל, אנו כוללים את כל המזהים שאינם דיפולטיביים. לדוגמא, אם ל-
`example.js`
יש ייצוא דיפולטיבי, יהיה עליכם לייבא אותו במפורש ואז לייצא אותו במפורש.

## ייבוא ללא הצהרה

ייתכן שמודולים מסוימים לא מייצאים שום דבר, ובמקום זאת רק מבצעים שינויים באובייקטים בסקופ הגלובלי. למרות שמשתנים, פונקציות ומחלקות ברמה העליונה במודולים אינם מגיעים באופן אוטומטי לסקופ הגלובלי, אין הדבר אומר שמודולים אינם יכולים לגשת לסקופ הגלובלי. ההגדרות המשותפות של אובייקטים מובנים כגון
`Array`
ו
`Object`
נגישים בתוך מודול ושינויים באובייקטים אלה יבואו לידי ביטוי במודולים אחרים.

לדוגמה, אם נרצה להוסיף שיטת
<span dir="ltr">`pushAll()`</span>
לכל המערכים, נוכל להגדיר מודול כזה:

<div dir="ltr">

```js
// מודול ללא ייבוא או ייצוא
Array.prototype.pushAll = function (items) {
  // items
  // חייב להיות מערך
  if (!Array.isArray(items)) {
    throw new TypeError("Argument must be an array.");
  }

  // משתמשים במתודה
  // push
  // המובנית יחד עם אופרטור הפיזור
  return this.push(...items);
};
```

</div>

זהו מודול תקף למרות שאין בו ייצוא או יבוא. ניתן להשתמש בקוד זה גם כמודול וגם כסקריפט. מכיוון שהוא לא מייצא דבר, ניתן להשתמש בייבוא פשוט כדי להריץ אותו:

<div dir="ltr">

```js
import "./example.js";

let colors = ["red", "green", "blue"];
let items = [];

items.pushAll(colors);
```

</div>

קוד זה מייבא ומריץ את המודול המכיל את המתודה
<span dir="ltr">`pushAll()`</span>,
כך ש
<span dir="ltr">`pushAll()`</span>
נוסף לפרוטוטייפ של המערך. פירוש הדבר ש-
<span dir="ltr">`pushAll()`</span>
זמין כעת לשימוש בכל המערכים שבתוך מודול זה.

I> יבוא ללא שימוש בחלקים מיובאים כנראה שישמש להשפעה על הקוד הגלובלי לשם תאימות ומניעת שגיאות ריצה
<span dir="ltr">(polyfills and shims)</span>.

## טעינת מודולים

בעוד ש-
ECMAScript 6
מגדיר את התחביר למודולים, הוא אינו מגדיר כיצד לטעון אותם. זה חלק מהמורכבות של מפרט שאמור להיות אגנוסטי לסביבות היישום. במקום לנסות ליצור מפרט יחיד שיעבוד בכל סביבות ה-
ג׳אווהסקריפט,
ECMAScript 6
מציין רק את התחביר וממצה את מנגנון הטעינה לפעולה פנימית לא מוגדרת הנקראת `HostResolveImportedModule`.
דפדפני האינטרנט ו-
Node.js
נותרו להחליט כיצד ליישם את
`HostResolveImportedModule`
באופן הגיוני לסביבותיהם.

### שימוש במודולים בדפדפני אינטרנט

עוד לפני
ECMAScript 6,
היו לדפדפני האינטרנט דרכים מרובות לכלול
ג׳אווהסקריפט
ביישום אינטרנט. אפשרויות טעינת סקריפט אלה הן:

1. טוען קבצי קוד
ג׳אווהסקריפט
באמצעות רכיב
`<script>`
עם התכונה
`src`
המציין מיקום ממנו ניתן לטעון את הקוד.
1. הטמעת קוד
ג׳אווהסקריפט
מוטבע באמצעות האלמנט
`<script>`
ללא התכונה
`src`.
1. טוען קבצי קוד
ג׳אווהסקריפט
לביצוע כ
worker
(כגון
web worker
או
service worker).

על מנת לתמוך במודולים באופן מלא, דפדפני האינטרנט נאלצו לעדכן כל אחד מהמנגנונים הללו. פרטים אלה מוגדרים במפרט ה-
HTML
ואני אסכם אותם בחלק זה.

#### שימוש במודולים עם `<script>`

התנהגות ברירת המחדל של האלמנט
`<script>`
היא לטעון קבצי
ג׳אווהסקריפט
כסקריפטים
(לא מודולים).
זה קורה כאשר התכונה
`type`
חסרה או כאשר התכונה
`type`
מכילה סוג תוכן של
ג׳אווהסקריפט
(
כגון
`"text/javascript"`
).
האלמנט
`<script>`
יכול לבצע קוד מוטבע או לטעון את הקובץ שצוין ב-
`src` .
כדי לתמוך במודולים, הערך
`"module"`
נוסף כאופציה ב
`type` .
הגדרת
`type`
ל
`"module"`
אומרת לדפדפן לטעון כל קוד או קוד מוטבעים הכלולים בקובץ שצוין על ידי
`src`
כמודול במקום סקריפט. הנה דוגמה פשוטה:

<div dir="ltr">

```html
<!-- load a module JavaScript file -->
<script type="module" src="module.js"></script>

<!-- include a module inline -->
<script type="module">
  import { sum } from "./example.js";

  let result = sum(1, 2);
</script>
```

</div>

האלמנט הראשון
`<script>`
בדוגמה זו טוען קובץ מודול חיצוני באמצעות התכונה
`src`.
ההבדל היחיד מטעינת סקריפט הוא ש
`"module"`
ניתן כ
`type`.
האלמנט השני
`<Script>`
מכיל מודול המוטמע ישירות בדף האינטרנט. המשתנה
`result`
אינו נחשף באופן גלובלי מכיוון שהוא קיים רק בתוך המודול
(
כהגדרתו על ידי האלמנט
`<script>`
)
ולכן אינו מתווסף ל
`window`
כמאפיין.

כפי שניתן לראות, כולל מודולים בדפי אינטרנט הוא די פשוט ודומה לכלול סקריפטים. עם זאת, ישנם כמה הבדלים באופן טעינת המודולים.

I> יתכן ששמת לב ש-
`"module"`
אינו סוג תוכן כמו סוג
`"text/javascript"`.
קבצי
JavaScript
מודוליים מוגשים עם אותו סוג תוכן כמו קבצי
JavaScript
של סקריפט, כך שלא ניתן להבדיל רק על פי סוג תוכן. כמו כן, דפדפנים מתעלמים מאלמנטים של
`<script>`
כאשר
`type`
אינו מזוהה, כך שדפדפנים שאינם תומכים במודולים יתעלמו אוטומטית משורת

<span dir="ltr">`<script type="module">`</span>,
ויספקו תאימות טובה לאחור.

#### רצף טעינת מודולים בדפדפני אינטרנט

המודולים הם ייחודיים בכך שבניגוד לתסריטים, הם עשויים להשתמש ב
`import`
כדי לציין שיש לטעון קבצים אחרים כדי לבצע אותם בצורה נכונה. כדי לתמוך בפונקציונליות זו,

<span dir="ltr">`<script type="module">`</span>
תמיד מתנהג כאילו מוחל התכונה
`defer`.

תכונת
`defer`
היא אופציונלית לטעינת קבצי סקריפט אך מוחלת תמיד לטעינת קבצי מודול. הורדת קובץ המודול מתחילה ברגע שמנתח ה-
HTML
נתקל ב-

<span dir="ltr">`<script type="module">`</span>
בתכונה
`src`
אך אינו מבוצע עד לאחר ניתוח המסמך לחלוטין. המודולים מבוצעים גם לפי סדר הופעתם בקובץ ה-
HTML.
פירוש הדבר שה-

<span dir="ltr">`<script type="module">`</span>
הראשון מובטח תמיד כי יבוצע לפני השני, גם אם מודול אחד מכיל קוד מוטבע במקום לציין `src`.
לדוגמה:

<div dir="ltr">

```html
<!-- this will execute first -->
<script type="module" src="module1.js"></script>

<!-- this will execute second -->
<script type="module">
  import { sum } from "./example.js";

  let result = sum(1, 2);
</script>

<!-- this will execute third -->
<script type="module" src="module2.js"></script>
```

</div>

שלושת האלמנטים
`<script>`
אלה מבצעים לפי סדר הגדרתם, ולכן מובטח ש-
`module1.js`
יבוצע לפני המודול המוטבע, ומובטח כי המודול המוטבע יבוצע לפני
`module2.js`.

כל מודול יכול
`import`
ממודול אחד או יותר, מה שמסבך את העניינים. זו הסיבה שמודלים מנותחים תחילה לחלוטין כדי לזהות את כל הצהרות ה
`import`.
כל הצהרת
`import`
ואז מפעילה אחזור
(מהרשת או מהמטמון)
, ואין מודול מבוצע עד שכל משאבי
`import`
נטענו והוצאו לראשונה. שלושת האלמנטים
`<script>`
אלה מבוצעים לפי הסדר. הם מוגדרים, ולכן מובטח ש-
`module1.js`
יבוצע לפני המודול המוטבע, ומובטח כי המודול המוטבע יבוצע לפני
`module2.js`.

כל המודולים, הן אלה שנכללו במפורש באמצעות

<span dir="ltr">`<script type="module">`</span>
וגם אלה שנכללו במשתמע באמצעות
`import`,
נטענים ומבוצעים לפי הסדר. בדוגמה הקודמת, רצף הטעינה השלם הוא:

1. הורד ונתח
`module1.js`.
1. הורד רקורסיבי ונתח את המשאבים
`import`
ב-
`module1.js`.
1. נתח את המודול המוטבע.
1. הורד ורקורסיבית משאבים של
`import`
במודול המוטבע.
1. הורד ונתח
`module2.js`.
1. הורד רקורסיבי ונתח את המשאבים
`import`
ב-
`module2.js`

לאחר השלמת הטעינה, דבר אינו מבוצע עד לאחר ניתוח המסמך לחלוטין. לאחר השלמת ניתוח המסמכים, מתרחשות הפעולות הבאות:

1. ביצוע רקורטיבי של משאבי
`import`
עבור
`module1.js`.
1. ביצוע
`module1.js`.
1. בצע רקורטיבי משאבי
`import`
עבור המודול המוטבע.
1. בצע את המודול המוטבע.
1. ביצוע רקורטיבי של משאבי
`import`
עבור
`module2.js`.
1. ביצוע
`module2.js`.

שימו לב כי המודול המוטבע מתנהג כמו שני המודולים האחרים, אלא שלא צריך להוריד את הקוד תחילה. אחרת, רצף טעינת משאבי
`import`
והפעלת מודולים זהה לחלוטין.

I> מתעלמים מהתכונה
`defer`
ב-
<span dir="ltr">`<script type="module">`</span>
מכיוון שהיא כבר מתנהגת כאילו מוחל על
`defer`.

#### טעינה של מודול אסינכרוני בדפדפני אינטרנט

ייתכן שכבר מכיר את התכונה
`async`
באלמנט
`<script>`.
בשימוש עם סקריפטים,
`async`
גורם להופעת קובץ הסקריפט ברגע שהקובץ מוריד ומנותח לחלוטין. סדר הסקריפטים
`async`
במסמך אינו משפיע על סדר ביצוע הסקריפטים. התסריטים מבוצעים תמיד ברגע שהם מסיימים את ההורדה מבלי להמתין לסיום הניתוח של המסמך המכיל.

ניתן להחיל את תכונת
`async`
גם על מודולים. השימוש ב-
`async`
ב-

<span dir="ltr">`<script type="module">`</span>
גורם למודול לבצע באופן דומה לתסריט. ההבדל היחיד הוא שכל משאבי ה
`import`
עבור המודול יורדו לפני ביצוע המודול עצמו. זה מבטיח שכל המשאבים שהמודול צריך לתפקד יורדו לפני ביצוע המודול;
אתה פשוט לא יכול להבטיח _מתי_ המודול יבוצע.
שקול את הקוד הבא:

<div dir="ltr">

```html
<!-- no guarantee which one of these will execute first -->
<script type="module" async src="module1.js"></script>
<script type="module" async src="module2.js"></script>
```

</div>

בדוגמה זו, ישנם שני קבצי מודולים הנטענים בצורה אסינכרונית. לא ניתן לדעת איזה מודול יבוצע תחילה פשוט על ידי התבוננות בקוד זה. אם
`module1.js`
מסתיים בהורדה ראשונה
(
כולל כל משאבי ה
`import`
שלה
),
היא תפעל תחילה. אם תחילה ההורדה של
`module2.js`
תסתיים, אז המודול יופעל תחילה במקום זאת.

## טעינת מודולים כ Workers

Workers,
כמו
web workers
ו
service workers,
מבצעים קוד
JavaScript
מחוץ להקשר דף האינטרנט. יצירת
worker
חדש כוללת יצירת מופע חדש
`worker`
(או מחלקה אחרת)
והעברת המיקום של קובץ
JavaScript.
מנגנון הטעינה המוגדר כברירת מחדל הוא טעינת קבצים כסקריפטים, כך:

<div dir="ltr">

```js
// load script.js as a script
let worker = new Worker("script.js");
```

</div>

כדי לתמוך בטעינת מודולים, מפתחי תקן
HTML
הוסיפו ארגומנט שני לבנאים אלה. הארגומנט השני הוא אובייקט עם מאפיין
`type`
עם ערך ברירת המחדל של
`"script"`.
ניתן להגדיר
`type`
ל
`"module"`
על מנת לטעון קבצי מודול:

<div dir="ltr">

```js
// load module.js as a module
let worker = new Worker("module.js", { type: "module" });
```

</div>

דוגמה זו טוענת את
`module.js`
כמודול במקום סקריפט על ידי העברת ארגומנט שני עם
`"module"`
כערך המאפיין
`type`.
(
המאפיין
`type`
נועד לחקות כיצד התכונה
`type`
של
`<script>`
מבדילה בין מודולים
וסקריפטים.
)
הטיעון השני נתמך לכל סוגי העובדים בדפדפן.

מודולי
Worker
זהים בדרך כלל לתסריטים של
Worker,
אך ישנם כמה יוצאים מן הכלל. ראשית, סקריפטים של
Worker
מוגבלים לטעון מאותו מקור כמו דף האינטרנט אליו הם מוזכרים, אך מודולי
Worker
אינם מוגבלים באותה מידה. למרות שמודולי
Worker
מגבילים את אותה הגדרת ברירת המחדל, הם יכולים גם לטעון קבצים עם כותרות
CORS (Cross-Origin Resource Sharing Sharing)
כדי לאפשר גישה. שנית, בעוד שסקריפט עובד יכול להשתמש בשיטת
<span dir="ltr">`self.importScripts()`</span>
לטעינת סקריפטים נוספים לעובד,
<span dir="ltr">`self.importScripts()`</span>
תמיד נכשל במודולי
Worker
מכיוון שכדאי להשתמש במקום זאת ב
`import`.

### רזולוציית מפרט מודול הדפדפן

כל הדוגמאות עד נקודה זו בפרק השתמשו בנתיב ספציפי של מודול יחסי כגון
<span dir="ltr">`"./example.js"`</span>.
הדפדפנים דורשים שמפרט המודול יהיה באחד מהפורמטים הבאים:

- התחל עם `/` כדי לפתור מספריית השורש
- התחל עם `/.` כדי לפתור מהספריה הנוכחית
- התחל עם `/..` -כדי לפתור מספריית האב
- פורמט כתובת אתר

לדוגמא, נניח שיש לך קובץ מודול הממוקם ב-
`https://www.example.com/modules/module.js`
המכיל את הקוד הבא:

<div dir="ltr">

```js
// imports from https://www.example.com/modules/example1.js
import { first } from "./example1.js";

// imports from https://www.example.com/example2.js
import { second } from "../example2.js";

// imports from https://www.example.com/example3.js
import { third } from "/example3.js";

// imports from https://www2.example.com/example4.js
import { fourth } from "https://www2.example.com/example4.js";
```

</div>

כל אחד ממפרט המודולים בדוגמה זו תקף לשימוש בדפדפן, כולל כתובת האתר המלאה בשורה הסופית
(
יהיה עליך להיות בטוח ש-
`ww2.example.com`
הגדיר כהלכה את שיתוף המשאבים המקוריים שלו
(CORS)
כותרות כדי לאפשר טעינה בין תחומים
)
.אלה הם הפורמטים היחידים שמציינים את המודול שהדפדפנים יכולים לפתור כברירת מחדל
(
אם כי המפרט של מטעין המודולים שעדיין לא הושלם יספק דרכים לפתור פורמטים אחרים
).
כלומר, חלק ממפרט המודולים הרגיל למראה אינו תקף בדפדפנים ויגרום לשגיאה, כגון:

<div dir="ltr">

```js
// invalid - doesn't begin with /, ./, or ../
import { first } from "example.js";

// invalid - doesn't begin with /, ./, or ../
import { second } from "example/index.js";
```

</div>

לא ניתן לטעון את כל אחד ממפרט המודולים הללו על ידי הדפדפן. שני המפרטים של המודולים הם בפורמט לא חוקי
(חסרים תווי ההתחלה הנכונים)
למרות ששניהם יעבדו כאשר הם משמשים כערך של
`src`
בתג
`<script>`.
זהו הבדל מכוון בהתנהגות בין
`<script>`
ל-
`import`.

## סיכום

ECMAScript 6
מוסיף מודולים לשפה כדרך לארוז ולפקוד פונקציונליות. מודולים מתנהגים אחרת מאשר סקריפטים, מכיוון שהם אינם משנים את ההיקף הגלובלי עם המשתנים, הפונקציות והמחלקות ברמה העליונה שלהם, ו
`this`
הוא
`undefined`.
כדי להשיג התנהגות זו, מודולים נטענים באמצעות מצב אחר.

עליך לייצא כל פונקציונליות שתרצה להעמיד לרשות צרכני המודול. ניתן לייצא משתנים, פונקציות ומחלקות, ויש גם אפשרות לייצוא ברירת מחדל אחד לכל מודול. לאחר הייצוא, מודול אחר יכול לייבא את כל השמות המיוצאים או חלקם. שמות אלה מתנהגים כאילו הוגדרו על ידי `const`
ופועלים ככריכות בלוקים שלא ניתן להגדיר מחדש באותו מודול.

מודולים לא צריכים לייצא שום דבר אם הם מבצעים מניפולציה במשהו בהיקף הגלובלי. ניתן למעשה לייבא ממודול כזה מבלי להכניס כל קוד לתחום המודול.

מכיוון שמודולים חייבים לפעול במצב אחר, הדפדפנים הציגו את

<span dir="ltr">`<script type="module">`</span>
כדי לאותת שיש לבצע את קובץ המקור או את הקוד המוטבע כמודול. קבצי מודולים שטעונים ב-

<span dir="ltr">`<script type="module">`</span>
נטענים כאילו מוחל עליהם תכונת
`defer`.
המודולים מבוצעים גם לפי סדר הופעתם במסמך המכיל לאחר הניתוח המלא של המסמך.

</div>