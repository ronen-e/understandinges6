<div dir="rtl">

# יכולות מערך משופרות

המערך הינו אובייקט ג'אווה סקריפט במהותו. עם זאת, בעוד אספקטים אחרים של ג'אווה סקריפט התפתחו במהלך הזמן, מערכים נותרו זהים עד ש-
ECMAScript5
הציגה מספר שיטות להפוך אותם לקלים יותר לשימוש.
ECMAScript6
המשיכה את מגמת השיפור של המערכים על ידי הוספת פונקציונליות רבה יותר, כמו שיטות יצירה חדשות של מערכים, הפיכת כמה שיטות שימושיות לנוחות יותר לכתיב, מערכים מאופיינים.

## יצירת מערך

לפני
ECMAScript6
היו שתי דרכים עיקריות ליצירת מערכים: קונסטרקטור (בנאי) של מערך
(`array`)
ותחביר מילולי. שתי הגישות מצריכות רישום של פריטי המערך בנפרד ובדרך כלל הן מוגבלות למדי.
אפשרויות להמרת אובייקט דמוי מערך (כלומר, אובייקט עם אינדקס מספרי ורכיב
`length`
) למערך היו גם הן מוגבלות ולעיתים קרובות דרשו קוד נוסף.
כדי להקל על יצירת מערכים בג'אווה סקריפט
ECMAScript 6
הוסיפה את המתודות
`Array.of()`
ו-
`Array.from()`

### Array.of()

אחת הסיבות ש-
ECMAScript6
הוסיפה מתודות חדשות ליצירת מערכים בג'אווה סקריפט היא לסייע למפתחים להמנע מהצורך להשתמש בקונסטרקטור של מערך.
הקונסטרקטור
`new Array()`
מתנהג באופן שונה בהתבסס על סוג וכמות הארגומנטים שהועברו אליו.

כך לדוגמא:

```js
let items = new Array(2);
console.log(items.length); // 2
console.log(items[0]); // undefined
console.log(items[1]); // undefined
```

זאת לעומת

```js
items = new Array("2");
console.log(items.length); // 1
console.log(items[0]); // "2"

items = new Array(1, 2);
console.log(items.length); // 2
console.log(items[0]); // 1
console.log(items[1]); // 2

items = new Array(3, "2");
console.log(items.length); // 2
console.log(items[0]); // 3
console.log(items[1]); //"2"
```

כאשר מועבר לקונסטרקטור של המערך ערך מספרי כארגומנט יחיד ערך זה יהווה את האורך
`length`
של המערך. לעומת זאת, אם מועבר לארגומנט של הקונסטרקטור ערך יחיד שאינו מספרי, ערך זה יהפוך לפריט האחד והיחיד במערך. אם מספר ערכים (מספריים או לא) מועברים לקונסטרקטור כארגומנטים ערכים אלו יהפכו אף הם לפריטים במערך. התנהגות זו הינה מסוכנת ומבולבלת כיוון שלא תמיד נוכל לדעת אלו סוגים של מידע הועברו לקונסטרקור בתור ארגומנטים.

ECMAScript6
מציגה את המתודה
`Array.of()`
כדי לפתור את הבעיה הזו.
`Array.of()`
פועלת באופו דומה לקונסטרקטור של
`Array`
אך אין לה מקרה מיוחד לגבי ערך מספרי יחיד. המתודה הזו יוצרת תמיד מערך המכיל את הארגומנטים שלו למספר הארגומנטים או לסוגם.
להלן מספר דוגמאות המשתמשות בשיטת
`Array.of()`

```js
let items = Array.of(1, 2);
console.log(items.length); // 2
console.log(items[0]); // 1
console.log(items[1]); // 2

items = Array.of(2);
console.log(items.length); // 1
console.log(items[0]); // 2

items = Array.of("2");
console.log(items.length); // 1
console.log(items[0]); // "2"
```

בכדי ליצור מערך באמצעות מתודת
`Array.of()`
פשוט נעביר לה את הערכים הרצויים במערך. כך למשל בדוגמא הראשונה לעיל נוצר מערך המכיל שני מספרים. המערך שבדוגמא השניה מכיל מספר אחד והמערך האחרון מכיל סטרינג אחד. הדבר דומה לשימוש במערך מילולי ואכן ניתן להשתמש במערך מילולי במקום
`Array.of()`
ליצירת מערכים מקוריים במרבית המקרים.
אך אם נרצה להעביר את הקונסטרקטור של המערך לפונקציה אז יתכן שנרצה להתשתמש במתודה
`Array.of()`
על מנת להבטיח התנהגות עקבית.

לדוגמא:

```js
function createArray(arrayCreator, value) {
  return arrayCreator(value);
}

let items = createArray(Array.of, value);
```

בקוד זה הפונקציה
`createArray()`
מקבלת פונקציה היוצרת מערך וערך להכניס לתוך המערך. נוכל להעביר
`Array.of()`
בתור הארגומנט הראשון לפונקציה
`createArray()`
על מנת ליצור מערך חדש. במקרה זה יהיה זה מסוכן להעביר רק
`Array`
ישירות מבלי שנוכל להבטיח שהערך
`(value)`
לא יהיה מספר.

- לתשומת לב: המתודה
  `Array.of()`
  אינה משתמשת במאפיין
  `Sumbol.species`
  (הנדון בפרק 9) על מנת לקבוע את סוג הערך החוזר. במקום זאת היא משתמשת בקונסטרקטור הנוכחי
  (`this`
  בתוך מתודת ה-
  `of()`
  על מנת לקבוע את סוג הנתונים הנכון להחזרה.

</div>
