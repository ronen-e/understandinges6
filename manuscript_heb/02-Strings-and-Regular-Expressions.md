<div dir="rtl">

# מחרוזות וביטויים רגולריים

מחרוזות נחשבות לאחד מסוגי הנתונים החשובים ביותר בעולם התכנות. הן מופיעות כמעט בכל שפת תכנות גבוהה, והיכולת לעבוד איתן בצורה טובה היא ידע הכרחי עבור מפתחים על מנת ליצור תוכנות מוצלחות. בהתאם לכך ביטויים רגולריים חשובים גם הם בזכות הכוח הנוסף שהם נותנים למפתחים ביחס לעבודה עם מחרוזות. 
בהמשך לכך, היוצרים של אקמהסקריפט 6 שיפרו מחרוזות וביטויים רגולריים באמצעות הוספת תכונות חדשות ויכולות שהיו חסרות עד עתה.
פרק זה נותן סקירה של שני סוגי השינויים.

## תמיכה טובה יותר ב Unicode

לפני אקמהסקריפט 6 מחרוזות בג׳אווהסקריפט היו מורכבות מתווים בקידוד של 16 ביטים
(UTF-16). 
כל רצף בן 16-ביט נחשב ל 
*יחידת קוד* 
שמייצגת תו אחד. כל התכונות והמתודות של מחרוזת, כמו תכונת 
`length` 
ומתודת ה
<span dir="ltr">`charAt()`</span> 
היו מבוססים על יחידות אלו בנות 16 ביט.
16 ביטים הספיקו פעם להכלת כל התווים. 
זה איננו המקרה הודות לערכת התווים שחשפה על ידי סולם התווים יוניקוד.

### נקודות קוד של UTF-16

הגבלת אורך התווים ל 16 ביט לא הייתה אפשרית עבור המטרה המוצהרת של מפתחי קידוד יוניקוד לספק מזהה ייחודי לכל תו. המזהים הייחודיים הללו שנקראים 
*נקודות קוד* 
 הם לא יותר מאשר מספרים שמתחילים מ-0. 
ניתן לחשוב על נקודות קוד בתור מזהה לתו, כאשר מספר מייצג תו מסוים. 
קידוד תוים חייב למפות נקודות קוד 
(code points) 
אל יחידות קוד 
(code units).

תחת הכללים של קידוד
UTF-16 
נקודות קוד יכולות להיות מורכבות ממספר רב של יחידות קוד.
את 
2^16^ 
נקודות הראשונות ב 
UTF-16 
מייצגים בתור יחידות קוד בודדות בנות 16 ביט. 
הטווח הזה נקרא בשם 
*המישור המולטילשוני הבסיסי* 
(*Basic Multilingual Plane* - BMP). 
כל מה שמצוי מחוץ לטווח הזה נמצא בתוך אחד מני מה שנקרא 
*מישורים נוספים* 
(*supplementary planes*) 
במצב כזה לא ניתן עוד לייצג נקודות קוד ביחידות בודדות בנות 16 ביט. 
קידוד 
UTF-16 
פותר את בעיה זו באמצעות מה שנקרא 
*זוגות חלופיים* 
(*surrogate pairs*) 
ובעצם מייצג נקודת קוד בודדת באמצעות 2 יחידות קוד בנות 16 ביט.
 ומכאן כל תו בתוך מחרוזת יכול שיהיה יחידת קוד בודדת עבור תווים מתוך ה 
BMP 
שתופס 16 ביט בזיכרון, 
או שיהיה מורכב מ 2 יחידות קוד עבור תווים מתוך המישורים הנוספים
שתופס 32 ביט בזיכרון.

באקמהסקריפט 5, כל הפעולות שניתן לבצע על מחרוזת מבוצעות על יחידות קוד בנות 16 ביט,
ומכאן ניתן לקבל תוצאות בלתי צפויות ממחרוזות בקידוד 
UTF-16 
אשר מכילות זוגות חלופיים,
כמו שניתן לראות בדוגמה הבאה:

<div dir="ltr">

```js
var text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(text.charAt(0));        // ""
console.log(text.charAt(1));        // ""
console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
```

</div>

`"𠮷"`
הוא תו יוניקוד בודד שמיוצג באמצעות זוגות חלופיים, ולכן, הפעולות שמבוצעות עליו בדוגמה הקודמת מתייחסות אליו כאל מחרוזת בעלת שני תווים בני 16 ביט כל אחד. 
המשמעות היא:

* האורך של המשתנה `text` הוא 2, במקום 1
* ביטוי רגולרי שמנסה לבודד תו אחד נכשל מכיוון שמבחינתו מדובר בשני תווים
* המתודה <span dir="ltr">`charAt()`</span> לא מסוגלת להחזיר תו תקין מכיוון שאף יחידת קוד בת 16 תווים מבין הזוגות החלופיים אינה ניתנת להדפסה

המתודה 
<span dir="ltr">`charCodeAt()`</span> 
גם היא אינה מסוגלת לזהות את התו בצורה תקינה. היא מחזירה את המספר התואם בן 16 ביט עבור כל יחידת קוד בנפרד, אבל זו הדרך הטובה ביותר להתקרב אל הערך האמיתי של המשתנה
`text` 
באקמהסקריפט 5

אקמהסקריפט 6 לעומת זאת, נותן מענה לבעיות אלו ונותן תמיכה לעבודה עם זוגות חלופיים.
בהמשך נדון במספר דוגמאות עקרוניות ליכולות החדשות שהתווספו

### <span dir="ltr">codePointAt()</span>

מתודה אחת שהתווספה לאקמהסקריפט 6 על מנת לתת תמיכה מלאה בקידוד 
UTF-16
היא המתודה
<span dir="ltr">`codePointAt()`</span>, 
שמחזירה את ערך נקודת הקוד של 
Unicode 
שתואמת למיקום נתון בתוך מחרוזת. 
המתודה מקבלת את מיקום נקודת הקוד ולא את מיקום התו הבודד ומחזירה ערך מספרי, כפי שניתן לראות בדוגמה הבאה:

<div dir="ltr">


```js
var text = "𠮷a";

console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
console.log(text.charCodeAt(2));    // 97

console.log(text.codePointAt(0));   // 134071
console.log(text.codePointAt(1));   // 57271
console.log(text.codePointAt(2));   // 97
```

</div>

המתודה
<span dir="ltr">`codePointAt()`</span>
מחזירה את אותו ערך שמחזירה המתודה 
<span dir="ltr">`charCodeAt()`</span>
אלא אם כן היא פועלת על תווים שאינם שייכים ל
BMP.
התו הראשון במשתנה 
הינו תו אחד שכזה ומורכב משתי יחידות קוד, ומכאן ערך התכונה 
`length` 
הוא 3 ולא 2. 
המתודה 
<span dir="ltr">`charCodeAt()`</span>
מחזירה רק את יחידת הקוד הראשונה עבור המיקום 0 במחרוזת, ולעומת זאת 
<span dir="ltr">`codePointAt()`</span>
מחזירה את נקודת הקוד המלאה, אף אם נקודת הקוד מורכבת ממספר יחידות קוד. 
שתי המתודות מחזירות את אותו ערך עבור מיקום מספר 1
(יחידת הקוד השנייה של התו הראשון) 
ועבור מיקום מספר 2 
(התו `"a"`).

שימוש במתודה
<span dir="ltr">`codePointAt()`</span>
על תו הינו הדרך הקלה ביותר לבדוק האם אותו תו מיוצג על ידי יחידת קוד בודדת או שתי יחידות קוד. להלן פונקציה שיכולה לשמש לבדיקה זו:

<div dir="ltr">


```js
function is32Bit(c) {
    return c.codePointAt(0) > 0xFFFF;
}

console.log(is32Bit("𠮷"));         // true
console.log(is32Bit("a"));          // false
```

</div>


הגבול העליון של תווים בני 16-ביט מיוצג במספר הקסאדצימלי בתור המספר
`FFFF`, 
לכן כל נקודת קוד מעל מספר זה חייבת להיות מיוצגת על ידי שתי יחידות קוד, ובסך הכל 32 ביטים

### <span dir="ltr">String.fromCodePoint()</span>

כאשר אקמהסקריפט מספקת דרך לעשות פעולה כלשהי, במקרים רבים היא גם מספקת דרך לעשות את הפעולה ההפוכה. ניתן להשתמש ב 
<span dir="ltr">`codePointAt()`</span> 
בכדי להשיג את ערך נקודת הקוד עבור תו כלשהו בתוך מחרוזת, בעוד ש 
<span dir="ltr">`String.fromCodePoint()`</span> 
 מייצרת לנו תו בודד מתוך נקודת קוד נתונה. לדוגמה:

<div dir="ltr">

```js
console.log(String.fromCodePoint(134071));  // "𠮷"
```

</div>


ניתן לחשוב על 
<span dir="ltr">`String.fromCodePoint()`</span> 
כאל שיפור של מתודת
<span dir="ltr">`String.fromCharCode()`</span> 
שתיהן נותנות את אותה תוצאה עבור כל התווים ב
BMP. 
קיים הבדל אך ורק כאשר בודקים נקודות קוד עבור תווים מחוץ ל-
BMP.

### <span dir="ltr">normalize()</span>

היבט אחד מעניין של 
Unicode 
הוא שתווים שונים יכולים להיחשב זהים למטרת מיון או השוואה. ישנן שתי שיטות להגדיר שוויון כזה. 
ראשית,
*שוויון קאנוני* 
(*canonical equivalence*) 
לפיו שתי סדרות של נקודות קוד נחשבות שוות מבכל הבחינות. 
לדוגמה, שילוב של שני תווים יכול להיות בעל שוויון קאנוני לתו אחד. 
 השיטה השנייה היא שוויון מבחינת 
*התאמה*
(*compatibility*). 
לפיו, שתי סדרות תואמות של נקודות קוד נראות שונות אך יכולות לשמש אחת במקום השנייה במצבים מסוימים.

מסיבות אלו, שתי מחרוזות אשר מייצגות באופן עקרוני את אותו הטקסט ייתכן שיכילו סדרות שונות של נקודות קוד. לדוגמה, התו
"æ" 
והמחרוזת בת שני התווים
"ae" 
יכולים לשמש אחד במקום השני אך אינם שווים זה לזה, אלא אם כן מעבירים אותם לצורה אחידה ״מנורמלת״.

אקמהסקריפט 6 תומך בנורמליזציה של קידוד
Unicode
על ידי המתודה
<span dir="ltr">`normalize()`</span>. 
המתודה יכולה לקבל פרמטר אחר מסוג מחרוזת שמייצג את אחת מצורות הנורמליזציה האפשריות:

<div dir="ltr">

* Normalization Form Canonical Composition (`"NFC"`)
* Normalization Form Canonical Decomposition (`"NFD"`)
* Normalization Form Compatibility Composition (`"NFKC"`)
* Normalization Form Compatibility Decomposition (`"NFKD"`)

</div>

צורת הנורמליזציה של המתודה כברירת מחדל הינה נורמליזציה מסוג
`"NFC"`

הסבר נרחב על ההבדלים בין ארבע צורות הנרמול נמצא מחוץ למטרות ספר זה. אולם חשוב לזכור שכאשר משווים מחרוזות יש לנרמל אותן קודם לכן לאותה צורה.
לדוגמה:

<div dir="ltr">

```js
var normalized = values.map(function(text) {
    return text.normalize();
});

normalized.sort(function(first, second) {
    if (first < second) {
        return -1;
    } else if (first === second) {
        return 0;
    } else {
        return 1;
    }
});
```

</div>

הקוד ממיר את המחרוזות בתוך מערך 
`values`
לצורה מנורמלת על מנת למיין את המערך לפי סדר האלף בית. 
ניתן למיין את המערך המקורי על ידי קריאה ל
<span dir="ltr">`normalize()` </span> 

<div dir="ltr">

```js
values.sort(function(first, second) {
    var firstNormalized = first.normalize(),
        secondNormalized = second.normalize();

    if (firstNormalized < secondNormalized) {
        return -1;
    } else if (firstNormalized === secondNormalized) {
        return 0;
    } else {
        return 1;
    }
});
```

</div>

ושוב, הדבר החשוב ביותר בדוגמת הקוד האחרונה היא שגם המשתנה
`first` 
וגם המשתנה 
`second` 
משתנים לצורה מנורמלת אחידה. דוגמאות אלו השתמשו בצורת ברירת המחדל 
(NFC)
אך באותה המידה ניתן לנקוב בשם כל אחת מהצורות האחרות, כמו בדוגמה הבאה: 


<div dir="ltr">

```js
values.sort(function(first, second) {
    var firstNormalized = first.normalize("NFD"),
        secondNormalized = second.normalize("NFD");

    if (firstNormalized < secondNormalized) {
        return -1;
    } else if (firstNormalized === secondNormalized) {
        return 0;
    } else {
        return 1;
    }
});
```

</div>

במידה ומעולם לא היית צריך לדאוג לגבי נורמליזציה של קידוד 
Unicode, 
סביר להניח שלא יהיה לך שימוש רב במתודה זו גם עתה. אך במידה ויהיה צורך לעבוד על 
אפליקציה שמותאמת לשפות אחרות, תגלו עד כמה שימושית המתודה 
<span dir="ltr">
`normalize()`
</span>

מתודות חדשות אינן השיפורים היחידים שאקמהסקריפט 6 מספקת עבור עבודה עם מחרוזות 
Unicode. 
אקמהסקריפט 6 הוסיפה שני אלמנטים תחביריים חדשים.

### סימון <span dir="ltr">u</span> בביטוי רגולרי

באמצעות ביטויים רגולריים ניתן לבצע פעולות נפוצות רבות. אך יש לזכור שביטויים רגולריים עובדים כברירת מחדל על יחידות קוד בנות 16 ביט, כאשר כל אחת מייצגת תו בודד. 
על מנת לפתור בעיה זו אקמהסקריפט 6 הגדירה סימון
`u` 
עבור ביטויים רגולריים.
הסימון 
`u`
 מייצג התייחסות ל 
Unicode. 

#### סימון <span dir="ltr">u</span> בפעולה

כאשר ביטוי רגולרי עובד תחת סימון
 `u`, 
הוא עובד על תווים, לא על יחידות קוד. 
המשמעות היא שהביטוי הרגולרי אמור לעבוד כמצופה גם כאשר הוא עובד על זוגות חלופיים. 
לדוגמה:

<div dir="ltr">

```js
var text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(/^.$/u.test(text));     // true
```

</div>

הביטוי הרגולרי
<span dir="ltr">`/^.$/`</span>
תואם כל מחרוזות בעלת תו אחד בלבד. 
כאשר משתמשים בו ללא סימון 
`u`,
הביטוי הרגולרי תואם ליחידות קוד בלבד. 
ועקב זאת האות היפנית שבדוגמה
(שמיוצגת על ידי שתי יחידות קוד) 
לא תואמת את הביטוי הרגולרי. 
אך כאשר משתמשים בסימון 
 `u` 
 הביטוי הרגולרי תואם לתווים ולכן התו היפני תואם לביטוי.

#### ספירת נקודות קוד

לרוע המזל, אקמהסקריפט 6 לא הוסיף שיטה לקביעת כמה נקודות קוד קיימות במחרוזת, אך על ידי שימוש עם בסימון 
`u` 
ניתן להשתמש בביטוי רגולרי כדי למצוא זאת. כפי שמודגם בהמשך:

<div dir="ltr">

```js
function codePointLength(text) {
    var result = text.match(/[\s\S]/gu);
    return result ? result.length : 0;
}

console.log(codePointLength("abc"));    // 3
console.log(codePointLength("𠮷bc"));   // 3
```

</div>

בקוד הנתון מבצעים קריאה לפונקציה 
<span dir="ltr">`match()`</span>

כדי לבדוק נוכחות של כל התווים במחרוזת 
`text`
באמצעות הביטוי הרגולרי
<span dir="ltr">`[\s\S]` </span> 
שמופעל גלובלית גם עבור 
<span dir="ltr">Unicode</span>. 
המשתנה 
`result`
מכיל מערך של תוצאות כאשר קיימת התאמה אחת לפחות, כך אורך המערך הוא גם מספר נקודות הקוד בתוך המחרוזת. 
לפי קידוד
<span dir="ltr">Unicode</span> 
 
המחרוזות  
`"abc"` 
ו-
 `"𠮷bc"` 
 שתיהן בעלות שלושה תווים ולכן אורך המערך שווה ל-3.

W> אף על פי
שטכניקה זו עובדת היא אינה מהירה במיוחד, בייחוד כאשר משתמשים בה על מחרוזות ארוכות. לשם כך ניתן להשתמש באיטרטור של מחרוזות
(עליו יוסבר בהרחבה בפרק 8).
כעקרון, נסו להימנע מספירת נקודות קוד ככל האפשר.

#### תמיכה עבור סימון u

מאחר וסימון
`u`
הינו שינוי תחבירי, ניסיון להשתמש בו בסביבת 
ג׳אווהסקריפט שאינה תומכת באקמהסקריפט 6 זורק שגיאה תחבירית 
<span dir="ltr">(syntax error)</span>.
הדרך הבטוחה לבדוק האם הסימון
`u`
נתמך היא על ידי שימוש בפונקציה כמו בדוגמה הבאה:

<div dir="ltr">

```js
function hasRegExpU() {
    try {
        var pattern = new RegExp(".", "u");
        return true;
    } catch (ex) {
        return false;
    }
}
```

</div>

הפונקציה בדוגמה משתמשת בקונסטרקטור 
`RegExp` 
כדי להעביר את הסימון 
`u`
כארגומנט לפונקציה.
התחביר עובד גם במנועי ריצה ישנים של ג׳אווהסקריפט, אך הקונסטרקטור יזרוק שגיאה בזמן הרצתו במידה והסימון
`u`
אינו נתמך.

I> במידה והקוד שלכם אמור לעבוד במנועי ריצה ישנים של ג׳אווהסקריפט, תמיד השתמשו בקונסטרקטור 
`RegExp` 
כאשר יש צורך להשתמש בסימון 
`u`
זה ימנע שגיאות תחביריות ויאפשר לכן להשתמש בו בצורה תקינה.

## שינויים נוספים

מחרוזות בג׳אווהסקריפט תמיד נשרכו מאחורי יכולות קיימות במחרוזות בשפות אחרות.
לשם הדוגמה, 
היה זה רק באקמהסקריפט 5 שמחרוזות זכו לשיטת
<span dir="ltr">`trim()` </span>
שמאפשרת לקצר רווחים בתחילת וסוף מילה. 
אקמהסקריפט 6 ממשיכה להרחיב את יכולות השפה לעבוד עם מחרוזות

### מתודות לזיהוי תת מחרוזות

מפתחים השתמשו במתודה
<span dir="ltr">`indexOf()`</span> 
כדי לזהות מחרוזות בתוך מחרוזות עוד מאז שג׳אווהסקריפט פותחה לראשונה. 
אקמהסקריפט 6 כוללת את שלושת המתודות הבאות שנועדו לבצע את אותה פעולה:

* המתודה 
<span dir="ltr">`includes()`</span>
מחזירה 
`true`
 אם הטקסט הנתון מופיע בתוך המחרוזת.
 אחרת, יוחזר
`false`.

* המתודה
<span dir="ltr">`startsWith()`</span>
מחזירה
`true`
אם הטקסט הנתון מופיע בתחילת המחרוזת. 
אחרת, יוחזר
`false`.

* המתודה
<span dir="ltr">`endsWith()`</span> 
מחזירה
`true`
אם הטקסט הנתון מופיע בסוף המחרוזת. 
אחרת, יוחזר
`false`.

כל מתודה מקבלת שני ארגומנטים:
הטקסט לחפש ואינדקס אפשרי.
כאשר הארגומנט השני מתקבל אזי המתודות 
<span dir="ltr">`includes()`</span>
ו-
<span dir="ltr">`startsWith()`</span>
מתחילות לחפש מאותו אינדקס, בעוד שהמתודה
<span dir="ltr">`endsWith()`</span> 
מתייחסת לאותו ארגומנט כאל אורך המחרוזת. 
כאשר הארגומנט השני חסר אזי המתודות 
<span dir="ltr">`includes()`</span>
ו-
<span dir="ltr">`startsWith()`</span>
מתחילות לחפש מתחילת המחרוזת בעוד שהמתודה 
<span dir="ltr">`endsWith()`</span> 
מחפשת מסוף המחרוזת
להלן מספר דוגמאות:

<div dir="ltr">

```js
var msg = "Hello world!";

console.log(msg.startsWith("Hello"));       // true
console.log(msg.endsWith("!"));             // true
console.log(msg.includes("o"));             // true

console.log(msg.startsWith("o"));           // false
console.log(msg.endsWith("world!"));        // true
console.log(msg.includes("x"));             // false

console.log(msg.startsWith("o", 4));        // true
console.log(msg.endsWith("o", 8));          // true
console.log(msg.includes("o", 8));          // false
```

</div>

שש הקריאות הראשונות למתודה בדוגמה לא כוללות ארגומנט שני, ולכן החיפוש יתבצע על כל אורך המחרוזת, במידת הצורך. שלוש הקריאות האחרונות בודקות רק חלק מהמחרוזת. הקריאה ל - 
<span dir="ltr">`msg.startsWith("o", 4)` </span>
מתחילה לחפש החל מסמן אינדקס מס׳ 4 של ערך המשתנה
`msg`,
שהוא התו
"o"
בתוך 
"Hello".
הקריאה ל
<span dir="ltr">`msg.endsWith("o", 8)`</span>
מתחילה את החיפוש החל מסמן אינדקס 0 וממשיכה עד לסמן אינדקס 7 
שהוא התו
"o"
בתוך 
"world".
הקריאה ל
<span dir="ltr">`msg.includes("o", 8)`</span>
מתחילה את החיפוש החל מסמן אינדקס 8 שהוא התו
"r" 
בתוך 
"world".

למרות ששלוש המתודות הללו מקלות על זיהוי קיומן של תת מחרוזות, הן כולן מחזירות ערך בוליאני. אם ברצונך למצוא את המיקום של מחרוזת אחת בתוך השנייה יש להשתמש במתודה
<span dir="ltr">`indexOf()`</span>
או
<span dir="ltr">`lastIndexOf()`</span>

W> המתודות 
<span dir="ltr">`startsWith()`</span>,
<span dir="ltr">`endsWith()`</span>,
ו- 
<span dir="ltr">`includes()`</span>
זורקות שגיאה כאשר מעבירים כארגומנט ראשון ביטוי רגולרי במקום מחרוזת. זוהי התנהגות שונה מאשר הקיימת במתודות 
<span dir="ltr">`indexOf()`</span>
ו-
<span dir="ltr">`lastIndexOf()`</span>,
שממירות ביטוי רגולרי למחרוזת ומחפשות את אותה מחרוזת.

### מתודת <span dir="ltr">repeat()</span>

אקמהסקריפט 6 הוסיפה מתודת 
<span dir="ltr">repeat()</span>
למחרוזות, שמקבלת כארגומנט את מספר הפעמים שיש לחזור על המחרוזת. 
המתודה מחזירה מחרוזת חדשה שמכילה את המחרוזת המקורית אשר חוזרים עליה את מספר הפעמים הנתון.
לדוגמה:


<div dir="ltr">

```js
console.log("x".repeat(3));         // "xxx"
console.log("hello".repeat(2));     // "hellohello"
console.log("abc".repeat(4));       // "abcabcabcabc"
```

</div>

המתודה משמשת בעיקר ככלי עזר, והיא שימושית מאוד כאשר מבצעים מניפולציה על טקסט. 
היא עוזרת במיוחד כאשר עורכים טקסט שדורש רמות שונות של הזחה, למשל:

<div dir="ltr">

```js
// הזחה על ידי מספר קבוע של רווחים
var indent = " ".repeat(4),
    indentLevel = 0;

// כל פעם שמגדילים הזחה
var newIndent = indent.repeat(++indentLevel);
```

</div>

הקריאה ראשונה למתודה
<span dir="ltr">`repeat()`</span>
יוצרת מחרוזת של ארבעה רווחים, והמשתנה
`indentLevel` 
עוקב אחר רמת ההזחה. 
כך, ניתן לקרוא למתודה 
<span dir="ltr">`repeat()`</span>
עם רמת הזחה שונה שמשנה את מספר הרווחים.

אקמהסקריפט 6 הביאה מספר שינויים מועילים לביטויים רגולריים כלליים. בהמשך יוצגו כמה מהם.

## שינויים בביטויים רגולריים

ביטויים רגולריים לוקחים חלק נכבד בעבודה עם מחרוזות בג׳אווהסקריפט, וכמו חלקים רבים אחרים של השפה הם לא השתנו הרבה בגרסאות הקודמות. 
לעומת זאת, אקמהסקריפט 6 הציגה מספר שיפורים לביטויים רגולריים בד בבד עם השינויים שנעשו במחרוזות.

### הסימון y

אקמהסקריפט 6 הפך את הסימון 
`y` 
לחלק מהשפה לאחר שהוכנס לדפדפן פיירפוקס באופן עצמאי לפיירפוקס בתור הרחבה לביטויים רגולריים בפיירפוקס בלבד. 
הסימון 
`y` 
משפיע על תכונת ה״דביקות״ - 
`sticky` 
של הביטוי הרגולרי, למעשה הוא גורם לחיפוש להתחיל לבדוק התאמות במחרוזת במיקום שנקבע על ידי תכונת 
`lastIndex`
של הביטוי הרגולרי. במידה ואין התאמה באותו מיקום, אזי הביטוי הרגולרי מפסיק לחפש התאמות.
לדוגמה:

<div dir="ltr">

```js
var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

pattern.lastIndex = 1;
globalPattern.lastIndex = 1;
stickyPattern.lastIndex = 1;

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // TypeError: Cannot read property '0' of null
```

</div>

בדוגמה זו מובאים שלושה ביטויים רגולריים.
הביטוי בתוך המשתנה 
`pattern`
הינו ללא סימונים, 
הביטוי במשתנה 
`globalPattern`
משתמש בסימון 
`g`,
והביטוי במשתנה
`stickyPattern` 
משתמש בסימון
`y`.
בשלוש הקריאות הראשונות ל - 
<span dir="ltr">`console.log()`</span>
כל שלושת הביטויים מחזירים את המחרוזת 
`"hello1 "` 
עם רווח בסוף המחרוזת.

לאחר מכן התכונה
`lastIndex`
נקבעת לערך 1 עבור כל שלושת הביטויים הרגולריים, כלומר הביטוי הרגולרי יחפש התאמות החל מהתו השני. 
הביטוי הרגולרי ללא סימון מתעלם מהשינוי לתכונה
`lastIndex`
ועדיין מוצא את ההתאמה 
`"hello1 "` . 
הביטוי הרגולרי עם סימון 
`g` 
ממשיך הלאה בחיפוש ומוצא התאמה עבור המחרוזת 
`"hello2 "` 
מכיוון והוא מחפש קדימה החל מהתו השני של המחרוזת 
(`"e"`). 
הביטוי הרגולרי ה״דביק״ לא מוצא התאמה כאשר הוא מחפש החל מהתו השני ולכן ערכו של המשתנה 
`stickyResult` 
הוא 
`null`.

הסימון הדביק שומר את סמן האינדקס של התו הבא לאחר ההתאמה האחרונה בתוך התכונה 
`lastIndex` 
לאחר סיום פעולת החיפוש. 
אם חיפוש מסתיים ללא התאמה אזי ערך התכונה 
`lastIndex` 
מאותחל חזרה ל 0. 
הסימון הגלובלי 
`g` 
מתנהג בצורה זהה כפי שמודגם בהמשך:

<div dir="ltr">

```js
var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 7
console.log(stickyPattern.lastIndex);   // 7

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // "hello2 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 14
console.log(stickyPattern.lastIndex);   // 14
```

</div>

ערך התכונה
`lastIndex` 
משתנה ל 7 לאחר הקריאה הראשונה ל 
<span dir="ltr">`exec()`</span>
ול 14 לאחר הקריאה השנייה
הן עבור המשתנה 
`stickyPattern`
והן עבור המשתנה 
`globalPattern`.

קיימים שני דברים נוספים שחשוב לדעת לגבי הסימון הדביק:

1. מתייחסים לתכונה 
`lastIndex` 
אך ורק כאשר משתמשים במתודות שקיימות על הביטוי הרגולרי, כגון המתודות 
<span dir="ltr">`exec()`</span>
ו- 
<span dir="ltr">`test()`</span>. 
העברת הביטוי הרגולרי למתודה של מחרוזת, כמו 
<span dir="ltr">`match()`</span>
לא תפעיל התנהגות דביקה.

1.  כאשר משתמשים בתו
`^`
כדי לחפש התאמה בתחילת מחרוזת, ביטוי רגולרי דביק יחפש התאמות אך ורק מתחילת המחרוזות
(או מתחילת השורה במצב התאמה רב שורות - `multiline`).
כל עוד ערך התכונה
`lastIndex` 
הוא 0, 
אזי התו
`^`
הופך את הביטוי הרגולרי הדביק לזהה לכזה שאינו דביק. 
אם ערך התכונה
`lastIndex`
אינו תואם להתחלת מחרוזת במצב שורה בודדת
<span dir="ltr">`(single-line mode)`</span>
או לתחילת שורה במצב רב שורות
<span dir="ltr">`(multiline mode)`</span>
הביטוי הרגולרי הדביק  לא ימצא התאמה.

כמו בסימונים אחרים של ביטויים רגולריים, ניתן לזהות את נוכחות הסימון על ידי שימוש בתכונה מיוחדת. 
במקרה זה עליכם לבדוק את התכונה
`sticky`,

כפי שמוצג בדוגמה הבאה:

<div dir="ltr">

```js
var pattern = /hello\d/y;

console.log(pattern.sticky);    // true
```

</div>

התכונה
`sticky`
מוגדרת כ 
`true`
במידה והסימון הדביק פעיל, ומקבלת את הערך 
`false`
במידה ולא.
התכונה 
`sticky`
אינה ניתנת לשינוי בדרך אחרת והיא נחשבת לתכונה בעלת ערך שניתן לקריאה בלבד

בדומה לסימון
`u`
הסימון 
`y`
מהווה שינוי תחבירי, ולכן יגרום לשגיאת תחביר 
<span dir="ltr">`(syntax error)`</span>
במנועי ריצה ישנים של ג׳אווהסקריפט.
ניתן להשתמש בגישה הבאה על מנת לזהות תמיכה בו:

<div dir="ltr">

```js
function hasRegExpY() {
    try {
        var pattern = new RegExp(".", "y");
        return true;
    } catch (ex) {
        return false;
    }
}
```

</div>

בדומה לבדיקה עבור הסימון 
`u` 
הפונקציה בדוגמה מחזירה את הערך
`false` 
אם לא ניתן ליצור ביטוי רגולרי עם הסימון
`y`. 
במידה ויש צורך להשתמש בסימון 
`y`
במנועי ריצה ישנים של ג׳אווהסקריפט יש להשתמש בקונסטרקטור 
`RegExp`
על מנת להימנע משגיאה תחבירית.

### העתקת ביטויים רגולריים

באקמהסקריפט 5, ניתן להעתיק ביטויים רגולרים על ידי העברתם לקונסטרקטור
`RegExp` 
כמו בדוגמה הבאה:

<div dir="ltr">

```js
var re1 = /ab/i,
    re2 = new RegExp(re1);
```

</div>

המשתנה
`re2`
הוא עותק של המשתנה 
`re1`. 
אבל אם מספקים את הארגומנט השני לקונסטרקטור 
`RegExp`, 
שתפקידו להגדיר את הסימונים עבור הביטוי הרגולרי, 
הקוד יפסיק לעבוד, כמו בדוגמה הבאה:

<div dir="ltr">

```js
var re1 = /ab/i,

    // זורק שגיאה באקמהסקריפט 5, עובד באקמהסקריפט 6
    re2 = new RegExp(re1, "g");
```

</div>

אם הקוד לעיל ירוץ בסביבת אקמהסקריפט 5, 
תיזרק שגיאה לפיה הארגומנט השני לא יכול להתקבל כאשר הארגומנט הראשון הוא ביטוי רגולרי.
אקמהסקריפט 6 שינתה את ההתנהגות כך שהארגומנט השני יעבוד ויקבע מחדש את הסימונים על הביטוי הרגולרי החדש. לדוגמה:

<div dir="ltr">

```js
var re1 = /ab/i,

    // זורק שגיאה באקמהסקריפט 5, עובד באקמהסקריפט 6
    re2 = new RegExp(re1, "g");


console.log(re1.toString());            // "/ab/i"
console.log(re2.toString());            // "/ab/g"

console.log(re1.test("ab"));            // true
console.log(re2.test("ab"));            // true

console.log(re1.test("AB"));            // true
console.log(re2.test("AB"));            // false

```

</div>

בקוד לעיל למשתנה 
`re1` 
קיים סימון 
`i`
עבור חיפוש לא רגיש
בעוד שלמשתנה 
`re2`
קיים רק הסימון 
`g`
עבור חיפוש גלובלי.
הקונסטרקטור לביטויים רגולריים
`RegExp` 
העתיק את הביטוי הרגולרי של המשתנה 
`re1` 
והחליף את הסימון מסוג 
`i`
בסימון מסוג 
`g`.
לולא סופק הארגומנט השני, המשתנה 
`re2` 
היה בעל סימונים זהים למשתנה
`re1`.

### התכונה `flags`

אקמהסקריפט הוסיפה תכונה חדשה שקשורה לסימונים בביטויים רגולריים.
באקמהסקריפט 5, היה ניתן לקבל את טקסט המקור השל ביטוי רגולרי באמצעות התכונה 
`source` 
אך בשביל לקבל את תיאור הסימונים עליו היה צורך להשתמש במתודה 
<span dir="ltr">`toString()`</span>
כפי שמוצג בדוגמה הבאה:

<div dir="ltr">

```js
function getFlags(re) {
    var text = re.toString();
    return text.substring(text.lastIndexOf("/") + 1, text.length);
}

// toString() => "/ab/g"
var re = /ab/g;

console.log(getFlags(re));          // "g"
```

</div>

הקוד בדוגמה ממיר ביטוי רגולרי למחרוזת ומחזיר את התווים שמופיעים לאחר התו
`/` 
האחרון. 
התווים הללו מייצגים את הסימונים על הביטוי הרגולרי.

אקמהסקריפט 6 מאפשרת לעשות את אותה פעולה בקלות על ידי הוספת התכונה 
`flags` 
בנוסף על התכונה 
`source`.
שתי התכונות הינן תכונות לקריאה בלבד.
באמצעות התכונה 
`flags` 
ניתן להשתמש בביטויים רגולריים באופן פשוט יותר בעת פתירת באגים ומימוש ירושה.

התכונה 
`flags` 
מחזירה ייצוג מחרוזת של כל הסימונים שמופעלים על ביטוי רגולרי נתון. לדוגמה:

<div dir="ltr">

```js
var re = /ab/g;

console.log(re.source);     // "ab"
console.log(re.flags);      // "g"
```

</div>

הקוד בדוגמה מחזיר את כל הסימונים על המשתנה
`re` 
ומדפיס אותם באמצעות כתיבת קוד מינימלית

השינויים שנסקרו בפרק זה מביאים שיפור עצום עבור מפתחים, אך אקמהסקריפט 6 מביאה שיפור גדול אף יותר. היא הוסיפה סוג חדש של כתיבה דינמית של מחרוזות  שהופכת עבודה עם מחרוזות לגמישה יותר מבעבר.

## Template Literals - טמפלייט ליטראלס

למחרוזות בג׳אווהסקריפט תמיד היו מגבלות ביחס למחרוזות בשפות תכנות אחרות.
עד אקמרהסקריפט 6, למחרוזות לא הייתה גישה למתודות שנסקרו בפרק זה, ושרשור מחרוזות הינו פשוט ביותר. על מנת לאפשר למפתחים לפתור בעיות מורכבות יותר, 
*טמפלייט ליטראלס*
מספקים צורת כתיבה שמאפשרת בתורה יצירת שפות לדומיין
<span dir="ltr">(domain-specific languages - DSLs)</span>
לצורך עבודה עם טקסט בדרך יותר בטוחה מאשר הדרכים הזמינות באקמהסקריפט 5 וקודם לכן.
(
שפת דומיין היא שפת תכנות למען תכלית ברורה מפורטת וצרה, בניגוד לשפות בעלות תכלית כללית כמו ג׳אווהסקריפט.
)
<!-- see #7
בוויקי של אקמהסקריפט ניתן למצוא את התיאור הבא על 
[template literal strawman](http://wiki.ecmascript.org/doku.php?id=harmony:quasis):
-->

> צורה זו מרחיבה את התחביר של אקמהסקריפט עם עטיפה על מנת לאפשר לספריות שונות לספק שפות דומיין שבאופן קל יחסית יוכלו לייצר, לעבד ולשנות תוכן משפות אחרות בצורה כזו שיהיו חסינות או עמידות להתקפות כמו 
XSS
הזרקת SQL
וכולי.

טמפלייט ליטראלס הינם התשובה של אקמהסקריפט 6 ליכולות שהיו חסרות בג׳אווהסקריפט עד כה:

* **כתיבת מחרוזות במספר שורות** צורה סטנדרטית לכתיבת מחרוזות על פני מספר שורות
* **בניית מחרוזת דינמית** היכולת להחליף חלקים במחרוזת בערכים השמורים במשתנים.
* **סידור HTML** היכולת לשנות מחרוזת בצורה כזו שבטוח להזריק אותה ישירות לתוך HTML

במקום הוספת פונקציונליות למחרוזות הקיימות בג׳אווהסקריפט, טמפלייט ליטראלס מייצגים גישה חדשה לפתרון הבעיות הללו.

### תחביר בסיסי

ברמה הכי בסיסית, טמפלייט ליטראלס עובדים כמו מחרוזות רגילות שתחומות בכל צד עם התו 
(`` ` ``) 
במקום מרכאות כפולות או בודדות. 
לדוגמה:

<div dir="ltr">

```js
let message = `Hello world!`;

console.log(message);               // "Hello world!"
console.log(typeof message);        // "string"
console.log(message.length);        // 12
```

</div>

הקוד לעיל מדגים שהמשתנה 
`message`
מכיל מחרוזת רגילה. 
התחביר של טמפלייט ליטראלס משמש ליצירת ערך המחרוזת שעובר השמה אל המשתנה 
`message`

במידה ותרצה להשתמש בתו
(`` ` ``) 
במחרוזת כזו יש להשתמש בו יחד עם קו נטוי הפוך
(`\`)
כמו בדוגמה הבאה:

<div dir="ltr">

```js
let message = `\`Hello\` world!`;

console.log(message);               // "`Hello` world!"
console.log(typeof message);        // "string"
console.log(message.length);        // 14
```

</div>

אין צורך ל״ברוח״ מרכאות כפולות או בודדות בתוך טמפלייט ליטראלס.

### מחרוזת רבת שורות

מפתחי ג׳אווהסקריפט רצו דרך ליצור מחרוזות רבות שורות מאז הגרסה הראשונה של השפה. אך כאשר משתמשים במרכאות כפולות או בודדות, מחרוזות חייבות להיות תחומות על פני שורה אחת בודדת.

#### המצב לפני אקמהסקריפט 6
 
הודות לבאג תחבירי עתיק יומין, ניתן לעקוף מגבלה זו. ניתן ליצור מחרוזות רבות שורות אם קיים קו הפוך נטוי 
 (`\`) 
לפני השורה החדשה.
ראה דוגמה:

<div dir="ltr">

```js
var message = "שורה 1 \
שורה 2";

console.log(message);       // "שורה 1 שורה 2"
```

</div>

המחרוזת במשתנה
`message` 
אינה מכילה תו לשורה חדשה כאשר היא מודפסת מאחר והקו הפוך נטוי נחשב להמשך המחרוזות ולא שורה חדשה. 
על מנת להציג שורה חדשה בפלט, עליך להוסיף אותו ידנית:

<div dir="ltr">

```js
var message = "שורה 1 \n\
שורה 2";

console.log(message);       // "שורה 1
                            //  שורה 2"
```
</div>

הקוד לעיל ידפיס
`
שורה 1
שורה 2
` 
על פני שתי שורות נפרדות, אך ההתנהגות נחשבת לבאג, ורבים ממליצים להימנע מכך

ניסיונות אחרים ליצור מחרוזות רבות שורות הסתמכו על מערכים או שרשור, לדוגמה:

<div dir="ltr">

```js
var message = [
    "שורה 1 ",
    "שורה 2"
].join("\n");

var message = "שורה 1 \n" +
    "שורה 2";
```

</div>

כל הניסיונות שתוארו לעיל השאירו טעם רע למפתחים ורצון לפתרון מוצלח יותר.

#### מחרוזת רבת שורות בדרך הקלה

טמפלייט ליטראלס מקלים על יצירת מחרוזות רבות שורות מכיוון שאין תחביר מיוחד. רק צריך להוסיף שורה חדשה במקום המתאים. 
לדוגמה:

<div dir="ltr">

```js
let message = `שורה 1
שורה 2`;

console.log(message);           // "שורה 1
                                //  שורה 2"
console.log(message.length);    // 13
```

</div>

כל ריווח בתוך הטמפלייט ליטראלס נחשב לחלק מהמחרוזת, ולכן יש להישמר מפני הזחה לא רצויה.
לדוגמה:

<div dir="ltr">

```js
let message = `שורה 1
               שורה 2`;

console.log(message);           // "שורה 1
                                //                 שורה 2"
console.log(message.length);    // 28
```

</div>

בדוגמה לעיל, כל הריווח לפני השורה השנייה של הטמפלייט ליטראלס נחשב לחלק מהמחרוזת. 
אם ברצונך לכתוב קוד שמכיל הזחה בתוכו, יש להתחיל את המחרוזת מתחילת השורה. 
ראה דוגמה:

<div dir="ltr">

```js
let html = `
<div>
    <h1>Title</h1>
</div>`.trim();
```

</div>

הקוד לעיל מתחיל את הטמפלייט ליטראלס בשורה הראשונה אך מכיל טקסט החל מהשורה השנייה.
תגיות ה - 
HTML 
מוזחות על מנת להיראות תקינות ואז מופעלת המתודה
<span dir="ltr">`trim()`</span>
בכדי למחוק את השורה התחילית הריקה.

יש באפשרותך להשתמש בתו 
<span dir="ltr">`\n`</span>
באופן מפורש בתוך טמפלייט ליטראלס בכדי לסמן באופן מפורש היכן קיימת שורה חדשה:

<div dir="ltr">

```js
let message = `שורה 1\nשורה 2`;

console.log(message);           // "שורה 1
                                //  שורה 2"
console.log(message.length);    // 13
```

</div>

### ביצוע החלפות

ההבדל האמיתי בין מחרוזות רגילות לבין טמפלייט ליטראלס הוא באפשרות לבצע 
*החלפות*. 
החלפות מאפשרות לך לשבץ כל ביטוי ג׳אווהסקריפט תקין בתוך טמפלייט ליטראלס ולייצר מחרוזות שמכילה את התוצאה.

החלפות תחומות על ידי פתיחה באמצעות 
<span dir="ltr">`${`</span>
וסגירה באמצעות
<span dir="ltr">`}`</span>
כאשר ניתן לשים באמצע כל ביטוי ג׳אווהסקריפט. 
ההחלפה הפשוטה ביותר היא לשבץ משתנים ישירות לתוך המחרוזות הסופית,
לדוגמה:

<div dir="ltr">

```js
let name = "ניקולאס",
    message = `שלום, ${name}.`;

console.log(message);       // "שלום, ניקולאס."
```

</div>

ההחלפה
`${name}`
מכניסה את ערך המשתנה המקומי
`name` 
לתוך המחרוזת שבתוך המשתנה 
`message`. 
המשתנה
`message` 
יכיל את התוצאה של ההחלפה באופן מיידי.

I> טמפלייט ליטראלס יכולים לגשת לכל משתנה שקיים בסביבה בה הוא מוגדר. 
ניסיון להשתמש במשתנה לא מוגדר בתוך טמפלייט ליטראלס יזרוק שגיאה הן במצב שמרני והן במצב לא שמרני 
<span dir="ltr">(strict and non-strict modes)</span>

מאחר וההחלפות נחשבות לביטוי ג׳אווהסקריפט, ניתן להחליף יותר מאשר רק משתנים. 
ניתן לשבץ תוצאות חישוב, קריאות לפונקציות, ועוד. 
לדוגמה:

<div dir="ltr">

```js
let count = 10,
    price = 0.25,
    message = `${count} פריטים עולים $${(count * price).toFixed(2)}.`;

console.log(message);       // "10 פריטים עולים $2.50."
```

</div>

הקוד בדוגמה לעיל מבצע חישוב כחלק מתוך טמפלייט ליטראלס. 
המשתנים 
`count`
ו
`price`
מוכפלים זה בזה כדי לקבל תוצאה ואז מעוגלים לשתי נקודות דצימליות באמצעות 
<span dir="ltr">`.toFixed()`</span>.
סימן הדולר לפני ההחלפה השנייה מודפס כמו שהוא ולא נחשב להחלפה מאחר ואינו מלווה בסימני פתיחה וסגירה של טמפלייט ליטראלס

טמפלייט ליטראלס נחשבים לביטויי ג׳אווהסקריפט ומכאן ניתן להכיל טמפלייט ליטראלס אחד בתוך השני.
לדוגמה:

<div dir="ltr">

```js
let name = "ניקולאס",
    message = `שלום, ${
        `השם שלי הוא ${ name }`
    }.`;

console.log(message);        // "שלום, השם שלי הוא ניקולאס."
```

</div>

בדוגמה לעיל מופיע טמפלייט ליטראלס אחד בתוך השני.
המשתנה 
`name`
מוכנס לתוך טמפלייט ליטראלס הפנימי.

### תגיות טמפלייט ליטראלס

עד כה ראית כיצד בעזרת טמפלייט ליטראלס ניתן ליצור מחרוזות רבות שורות ולהכניס ערכים לתוך מחרוזות ללא שרשור. אך הכוח האמיתי של טמפלייט ליטראלס בא מתגיות טמפלייט ליטראלס.
*תגית טמפלייט ליטראלס* 
פועלת על הטמפלייט ליטראלס ומחזירה ערך מחרוזת סופי. 
התגית מופעלת בראשית הטמפלייט ליטראלס, 
ממש לפני התו
`` ` `` 
הראשון, 
כמו בדוגמה הבאה:

<div dir="ltr">

```js
let message = tag`Hello world`;
```

</div>

בדוגמה זו 
המשתנה 
`tag` 
הינו התגית 
שמופעלת על הטמפלייט ליטראלס 
<span dir="ltr">`` `Hello world` ``</span>.

#### הגדרת תגית

*תגית*
היא לא יותר מאשר פונקציה שנקראת על טמפלייט ליטראלס ומעבדת את הנתונים שלו.
התגית מקבלת את הנתונים של הטמפלייט ליטראלס בחתיכות ועליה לחבר אותן על מנת ליצור את התוצאה הרצויה.
הארגומנט הראשון הוא מערך אשר מכיל את ערכי המחרוזות הבודדות. כל ארגומנט לאחר מכן הינו הערך עבור כל החלפה.

פונקציות תגיות מוגדרות בד״כ בעזרת שימוש בארגומנט רסט
`rest` 
כפי שמופיע בדוגמה הבאה, על מנת להקל על עיבוד המידע.

<div dir="ltr">

```js
function tag(literals, ...substitutions) {
    // יש להחזיר מחרוזת
}
```

</div>

הדוגמה הבאה ממחישה את מה שמועבר לתגית:

<div dir="ltr">

```js
let count = 10,
    price = 0.25,
    message = passthru`${count} פריטים עולים $${(count * price).toFixed(2)}.`;
```

</div>

הפונקציה

<span dir="ltr">`passthru()`</span>
תקבל שלושה ארגומנטים.
ראשית, היא תקבל מערך 
<span dir="ltr">`literals`</span>

שיכיל את האלמנטים הבאים:

* המחרוזת הריקה לפני ההחלפה הראשונה (`""`)
* המחרוזת לאחר ההחלפה הראשונה ולפני השנייה (`" פריטים עולים $"`)
* המחרוזת לאחר ההחלפה השנייה (`"."`)

הארגומנט הבא יהיה
`10`, 
שהוא הערך המוחלף עבור המשתנה 
`count`. 
הוא יהיה האלמנט הראשון במערך 
`substitutions`. 
הארגומנט האחרון יהיה 
`"2.50"`, 
שהוא הערך המוחזר מהביטוי 
<span dir="ltr">`(count * price).toFixed(2)` </span>
והוא יהיה האלמנט השני במערך 
`substitutions`. 

יש להקדיש תשומת לב לכך שהערך הראשון במערך 
הינו מחרוזת ריקה.
<span dir="ltr">`literals[0]`</span>
הינו תמיד התחלת המחרוזת, 
ממש כמו ש
<span dir="ltr">`literals[literals.length - 1]`</span> 
הינו תמיד סוף המחרוזת.
מספר ההחלפות תמיד קטן באחד ממספר המחרוזות שבתוך 
`literals`. 
כתוצאה מכך ניתן להסיק כי:

<span dir="ltr">

```js
substitutions.length === literals.length - 1  // true
```
</span> 

בשיטה זו,
המערכים 
`literals` 
ו-
 `substitutions`
יכולים לשמש ליצירת מחרוזת.
האלמנט הראשון בתוך 
`literals`
מתחיל את המחרוזות.
לאחר מכן בא הערך הראשון בתוך 
 `substitutions` 
וכך הלאה, 
עד שהמחרוזת הושלמה.
כך ניתן למשל לחקות את ההתנהגות הרגילה של טמפלייט ליטראלס:

<div dir="ltr">

```js
function passthru(literals, ...substitutions) {
    let result = "";

    // מריצים את הלולאה כמספר ההחלפות
    for (let i = 0; i < substitutions.length; i++) {
        result += literals[i];
        result += substitutions[i];
    }

    // מוסיפים את המחרוזת האחרונה
    result += literals[literals.length - 1];

    return result;
}

let count = 10,
    price = 0.25,
    message = passthru`${count} פריטים עולים $${(count * price).toFixed(2)}.`;

console.log(message);       // "10 פריטים עולים $2.50."
```

</div>

הדוגמה לעיל מגדירה תגית
`passthru` 
שמבצעת את אותה פעולה כמו התנהגות רגילה של טמפלייט ליטראלס. 
החלק המעניין הוא השימוש בערך
`substitutions.length` 
עבור הרצת הלולאה במקום להשתמש ב 
`literals.length`
בכדי להימנע מלעבור את סוף מערך 
`substitutions`. 
פעולה זו עובדת בצורה תקינה מכיוון וההתנהגות עבור 
`literals`
ו-
`substitutions` 
מוגדרת היטב באקמהסקריפט 6.

I> הערכים בתוך מערך 
`substitutions` 
לא יהיו מחרוזות בהכרח. 
אם ערכו של ביטוי הוא מספר, כמו בדוגמה האחרונה, אותו ערך יועבר כארגומנט. 
על התגית להחליט כיצד להשתמש באותו ערך.

#### ערכים גולמיים בטמפלייט ליטראלס

תגיות טמפלייט ליטראלס יכולות לגשת גם לנתוני מחרוזת גולמיים, שבאופן בסיסי 
מאפשר גישה לתווים מיוחדים לפני המרתם לתווים. הדרך הפשוטה ביותר לעבוד עם ערך מחרוזת גולמית הינה להשתמש בתגית המובנית
<span dir="ltr">`String.raw()`</span> 
לדוגמה:

<div dir="ltr">

```js
let message1 = `שורה 1\nשורה 2`,
    message2 = String.raw`שורה 1\nשורה 2`;

console.log(message1);          // "שורה 1
                                //  שורה 2"
console.log(message2);          // "שורה 1\nשורה 2"
```

</div>

בדוגמת הקוד לעיל התו 
<span dir="ltr">`\n`</span> 
בתוך המשתנה
`message1` 
מחושב בתור שורה חדשה בעוד שהתו 
<span dir="ltr">`\n`</span> 
בתוך המשתנה
`message2`
מוחזר בצורתו הגולמית 
<span dir="ltr">`"\\n"`</span> 
(
הקו הנטוי והתו 
`n`
). 
שימוש בצורה הגולמית של המחרוזת בצורה זו מאפשרת לבצע עיבוד מורכב באופן נוח וקל יותר של מחרוזות במידת הצורך מאשר היה בעבר.

המידע הגולמי במחרוזות מועבר גם לתוך תגיות טמפלייט ליטראלס. הארגומנט הראשון בפונקציית תגיד הינו מערך שאליו התווספה התכונה בשם 
`raw`. 
התכונה 
`raw` 
הינה מערך המכיל את הערך הגולמי של כל ערך מילולי. 
לדוגמה, 
הערך בתוך המשתנה 
<span dir="ltr">`literals[0]`</span> 
תמיד בעל הערך המקביל 
<span dir="ltr">`literals.raw[0]`</span> 
אשר מכיל את הערך הגולמי של המחרוזת. 
באפשרותך לחקות את התנהגות הפונקציה 
<span dir="ltr">`String.raw()`</span> 
על ידי הקוד להלן:

<div dir="ltr">

```js
function raw(literals, ...substitutions) {
    let result = "";

    // הלולאה תרוץ מספר פעמים כמספר ההחלפות
    for (let i = 0; i < substitutions.length; i++) {
        result += literals.raw[i];      // שימוש בערכים מילוליים גולמיים
        result += substitutions[i];
    }

    // הוספת הערך המילולי האחרון
    result += literals.raw[literals.length - 1];

    return result;
}

let message = raw`שורה 1\nשורה 2`;

console.log(message);           // "שורה 1\nשורה 2"
console.log(message.length);    // 14
```

</div>

בדוגמה נעשה שימוש בערך
<span dir="ltr">`literals.raw`</span>  
במקום בערך 
`literals` 
לצורך הצגת התוצאה. 
כל תו מיוחד יופיע בצורתו הגולמית. 
מחרוזות גולמיות יהיו שימושיות במיוחד כאשר רוצים להציג טקסט שבו קיים צורך להציג את התו המיוחד, 
(למשל, כאשר רוצים לייצר דוקומנטציה ורוצים להציג את הקוד המקורי).

## סיכום

תמיכה מלאה ב 
<span dir="ltr">Unicode</span> 
מאפשרת עבודה עם תווים בקידוד 
<span dir="ltr">UTF-16 </span>  
בצורה נוחה יותר. היכולת לעבור בין תו לבין נקודת קוד בעזרת
<span dir="ltr">`codePointAt()`</span> 
ו- 
<span dir="ltr">`String.fromCodePoint()`</span> 
מהווה שלב חשוב בעיבוד מחרוזות.
ההוספה של סימון
`u`
לביטויים רגולריים מאפשרת לעבוד על נקודות קוד ולא רק על תווים בגודל 16 ביט, ומתודת 
<span dir="ltr">`normalize()`</span> 
נותנת לנו אפשרות להשוות בצורה טובה יותר בין מחרוזות

אקמהסקריפט 6 הוסיפה שיטות חדשות לעבודה עם מחרוזות, שמאפשרות לנו לזהות תת מחרוזות ללא קשר למיקומן במחרוזת המקורית.
יכולות נוספות התווספו גם לביטויים רגולריים.

טמפלייט ליטראלס מהווים תוספת חשובה לאקמהסקריפט 6 שמרשה לנו ליצור שפות דומיין 
<span dir="ltr">(DSL)</span> 
ובכך ליצור מחרוזות בקלות. היכולת לשבץ משתנים ישירות לתוך טמפלייט ליטראלס נותנת למפתחים כלי עדיף מאשר שרשור מחרוזות שהיה נהוג בעבר לצורך שילוב מחרוזות עם משתנים.

תמיכה במחרוזות רבות שורות משדרגת את השפה עם יכולת שימושית שכלל לא הייתה קיימת קודם לכן.
למרות שניתן להשתמש בשורות חדשות ישירות בתוך טמפלייט ליטראלס, עדיין נשמרת היכולת להשתמש בתווים מיוחדים כרגיל, כולל התו
<span dir="ltr">`\n`</span> 
עבור הוספת שורה חדשה במחרוזת באופן מפורש.

תגיות טמפלייט ליטראלס מהוות את העיקר ביכולת ליצירת שפות דומיין. תגיות הן פונקציות שמקבלות את החתיכות שמרכיבות טמפלייט ליטראלס בתור ארגומנטים. בהמשך ניתן להשתמש בנתונים אלו על מנת להרכיב מחרוזת כרצונך. 
הנתונים שמסופקים לתגית כוללים ערכים מילוליים, המקבילות הגולמיות שלהם, וכל ערך מוחלף. 
באמצעות חתיכות נפרדות אלו ניתן להרכיב את הפלט המתאים לתגית.

</div>