<div dir="rtl">

# נספח ב: להבין אקמהסקריפט 7 (2016)

לקח כ-4 שנים לפתח את אקמהסקריפט 6. ולאחר מכן
TC-39
הגיעה לכלל החלטה שתהליך פיתוח ארוך כל כך אינו בר קיימא. תחת זאת, הוחלט לעבור למחזור שחרור גרסאות שנתי כדי לאפשר לתכונות חדשות של השפה להיכנס לאפיון מוקדם יותר.

שחרורים בתדירות גבוהה יותר משמעותם שכל מהדורה חדשה של אקמהסקריפט תכיל פחות שינויים יחסית לאקמהסקריפט 6. כדי לתת משמעות לשינוי זה, גרסאות חדשות של השפה לא יציגו את מספר המהדורה ובמקום זאת יתייחסו לשנת הפרסום. כתוצאה מכך, אקמהסקריפט 6 ידועה גם בתור אקמהסקריפט 2015 ואקמהסקריפט 7 ידועה באופן רשמי בתור אקמהסקריפט 2016.
TC-39
מצפה להשתמש בשיטת השמות על בסיס השנה עבור כל גרסאות אקמהסקריפט העתידיות.

אקמהסקריפט 2016 פורסמה במרץ 2016 והכילה רק 3 תוספות לשפה:
אופרטור מתמטי חדש, מתודת מערך חדשה, ושגיאת תחביר חדשה.
נספח זה ירחיב על כך.

## האופרטור המעריכי

השינוי היחיד לתחביר בג׳אווהסקריפט שהוצג בגרסת אקמהסקריפט 2016 הינו
*האופרטור המעריכי*
(*exponentiation operator*),
שמבטא פעולה מתמטית שמגדילה בסיס במעריך.
בג׳אווהסקריפט כבר הייתה קיימת המתודה
<span dir="ltr">`Math.pow()`</span>
שביצעה הגדלה במעריך, אך ג׳אווהסקריפט הייתה אחת מהשפות הבודדות שדרשה מתודה לשם ביצוע הפעולה ולא היה לה אופרטור רשמי לכך
(וישנם מפתחים שטוענים שאופרטור הינו קל יותר לקריאה והבנה).

האופרטור המעריכי מורכב משת כוכביות
(`**`)
כאשר האופרנד השמאלי הינו הבסיס והאופרנד הימני הינו המעריך.
לדוגמה:

<div dir="ltr">

```js
let result = 5 ** 2;

console.log(result);                        // 25
console.log(result === Math.pow(5, 2));     // true
```

</div>

הדוגמה לעיל מחשבת
<span dir="ltr">5^2^</span>,
שערכו 25.
ניתן עדיין להשתמש במתודה
<span dir="ltr">`Math.pow()`</span>
על מנת להשיג את אותה התוצאה.

### סדר הפעולות

האופרטור המעריכי בעל העדיפות הגבוהה ביותר מכל האופרטורים הבינאריים בג׳אווהסקריפט
(לאופרטורים אונאריים יש עדיפות גבוהה יותר מאשר
`**`).
המשמעות היא שהוא מופעל קודם כל עבור כל פעולה מורכבת,
כמו בדוגמה הבאה:

<div dir="ltr">

```js
let result = 2 * 5 ** 2;
console.log(result);        // 50
```

</div>

ראשית כל נעשה החישוב עבור
<span dir="ltr">5^2^</span>.
התוצאה מוכפלת ב-2 ונקבל תוצאה סופית של 50.

### הגבלת אופרנדים

עבור האופרטור המעריכי קיימת מגבלה שאינה קיימת עבור אופרטורים אחרים. הצד השמאלי של האופרטור לא יכול להיות ביטוי אונארי מלבד
`++`
או
`--`.
הדוגמה הבאה מציגה תחביר לא תקני:


<div dir="ltr">

```js
// שגיאת תחביר
let result = -5 ** 2;
```

</div>

המספר
`-5`
בדוגמה זו נחשב לשגיאה תחבירית מכיוון שסדר הפעולות אינו ברור.
האם הסימן
`-`
מופעל רק עבור הערך
`5`
או עבור תוצאת הביטוי
<span dir="ltr">`5 ** 2`</span> ?
הטלת איסור על ביטויים אונאריים בצידו השמאלי של האופרטור מבטלת את חוסר הבהירות.
על מנת להבהיר את הכוונה, יש להוסיף סוגריים מסביב למספר
`-5`
או מסביב לביטוי
`5 ** 2`
כמו בדוגמה הבאה:

<div dir="ltr">

```js
// תקין
let result1 = -(5 ** 2);    // -25

// גם תקין
let result2 = (-5) ** 2;    // 25
```

</div>

אם נשים את הסוגריים מסביב לביטוי, הסימן
`-`
פועל על כל הביטוי.
כאשר הסוגריים מופיעים מסביב לערך
`-5`,
ברור שהכוונה היא להגדיל את
-5
בריבוע.

אין צורך להשתמש בסוגריים עבור האופרטורים
`++`
ו-
`--`
בצד השמאלי של האופרטור המעריכי מכיוון שלשני האופרטורים יש התנהגות מוגדרת היטב על האופרנדים שלהם. מקדם של
`++`
או
`--`
משנה את האופרנד לפני ביצוע כל פעולה אחרת והגרסה של האופרטורים שמופיעה מצד ימין של האופרנד לא מבצעת שינוי עד לאחר קריאת כל הביטוי כולו. שני הסוגים בטוחים לשימוש בצד השמאלי של האופרטור המעריכי, כפי שרואים בדוגמה הבאה:

<div dir="ltr">

```js
let num1 = 2,
    num2 = 2;

console.log(++num1 ** 2);       // 9
console.log(num1);              // 3

console.log(num2-- ** 2);       // 4
console.log(num2);              // 1
```

</div>

בדוגמה זו,
`num1`
מועלה בערכו לפני שמופעל האופרטור המעריכי,
לכן
`num1`
הופך למספר 3
ותוצאת האופרציה היא
9.
עבור
`num2`,
הערך נשאר 2 עבור פעולת האופרטור המעריכי ואז משתנה ערכה ל 1.

## <span dir="ltr">Array.prototype.includes()</span>

ייתכן שתזכרו שאקמהסקריפט 6 הוסיפה את המתודה
<span dir="ltr">`String.prototype.includes()`</span>
על מנת לבדוק האם תת מחרוזת מסוימת קיימת בתוך מחרוזת נתונה. במקור אקמהסקריפט 6 הייתה אמורה להוסיף את המתודה
<span dir="ltr">`A`rray.prototype.includes()`</span>
כדי להמשיך המנהג של התייחסות למחרוזות ומערכים בצורה דומה. אך האפיון עבור
<span dir="ltr">`Array.prototype.includes()`</span>
לא הושלם על מועד הסיום עבור הגשת אקמהסקריפט 6
ולכן
<span dir="ltr">`Array.prototype.includes()`</span>
הועבר לאקמהסקריפט 2016.

## כיצד להשתמש ב <span dir="ltr">Array.prototype.includes()</span>

המתודה
<span dir="ltr">`Array.prototype.includes()`</span>
מקבלת שני ארגומנטים:
הערך לחיפוש ואינדקס אופציונלי שממנו להתחיל את החיפוש.
כאשר נתון הארגומנט השני

מתחילה לחפש החל מאותו אינדקס.
(
    אינדקס ברירת המחדל לחיפוש הוא
    `0`.
).
הערך שיוחזר יהיה
`true`
אם הערך מופיע במערך או
`false`
אם אינו מופיע במערך.

<div dir="ltr">

```js
let values = [1, 2, 3];

console.log(values.includes(1));        // true
console.log(values.includes(0));        // false

// החיפוש יתחיל החל מאינדקס 2
console.log(values.includes(1, 2));     // false
```
</div>

בדוגמה זו, קריאה לקוד
<span dir="ltr">`values.includes()`</span>
מחזירה
`true`
עבור הערך
`1`
ותחזיר
`false`
עבור הערך
`0`
מכיוון שהערך
`0`
אינו מופיע במערך.
כאשר הארגומנט השני משמש כדי להתחיל את החיפוש מאינדקס 2
(שמכיל את הערך
`3`),
המתודה
<span dir="ltr">`values.includes()`</span>
מחזירה
`false`
מכיוון שהמספר
`1`
לא מופיע החל מאינדקס 2 ועד סוף המערך.

### השוואת ערכים

ההשוואה שמבוצעת על ידי המתודה
<span dir="ltr">`includes()`</span>
משתמשת באופרטור
`===`
עם יוצא דופן אחד:
`NaN`
נחשב זהה לערך
`NaN`
אף על פי שהביטוי
`NaN === NaN`
מחזיר את הערך
`false`.
זוהי אינה התנהגות זהה לזו של המתודה
<span dir="ltr">`indexOf()`</span>
שמשתמשת אך ורק באופרטור
`===`
לצורך השוואה.
כדי לראות את ההבדל נשתמש בדוגמה הבאה:

<div dir="ltr">

```js
let values = [1, NaN, 2];

console.log(values.indexOf(NaN));       // -1
console.log(values.includes(NaN));      // true
```

</div>

המתודה
<span dir="ltr">`values.indexOf()`</span>
מחזירה את הערך
`-1`
עבור
`NaN`
למרות ש
`NaN`
מופיע במערך
`values`

W> כאשר נרצה לבחון את הופעת הערך במערך ואין צורך לדעת את מיקומו, מומלץ להשתמש במתודה
<span dir="ltr">`includes()`</span>
בגלל השוני ביחס לערך
`NaN`
בין המתודה
<span dir="ltr">`includes()`</span>
למתודה
<span dir="ltr">`indexOf()`</span>.
אם נרצה לדעת את מיקום הערך במערך, ניאלץ להשתמש במתודה
<span dir="ltr">`indexOf()`</span>.

חשוב לדעת שבעת השוואה, הערכים
`+0`
וגם
`-0`
נחשבים זהים. במקרה זה ההתנהגות בעבור המתודות
<span dir="ltr">`indexOf()`</span>
וגם
<span dir="ltr">`includes()`</span>
זהה:

<div dir="ltr">

```js
let values = [1, +0, 2];

console.log(values.indexOf(-0));        // 1
console.log(values.includes(-0));       // true
```

</div>

בדוגמה לעיל המתודות
<span dir="ltr">`includes()`</span>
ו-
<span dir="ltr">`indexOf()`</span>
מאתרות את
`+0`
כאשר משתמשים בערך
`-0`
כפרמטר מכיוון ששני הערכים נחשבים לזהים. שימו לב לכך שזוהי התנהגות שונה מזו של המתודה
<span dir="ltr">`Object.is()`</span>,
שמתייחסת לערכים
`+0`
ו-
`-0`
כאל ערכים שונים.

## שינוי במצב קפדני בתוך פונקציה

כאשר מצב קפדני הופיע לראשונה באקמהסקריפט 5, השפה הייתה פשוטה יותר יחסית למה שנהייתה באקמהסקריפט 6. למרות זאת אקמהסקריפט 6 עדיין אפשרה לנו להגדיר מצב קפדני על ידי שימוש בפקודת
<span dir="ltr">`"use strict"`</span>
במרחב הגלובלי
(שיגרום לכל הקוד לרוץ במצב קפדני)
או בתור מרחב פונקציה
(מה שיגרום רק לפונקציה לרוץ במצב קפדני).
המצב השני היווה בעיה באקמהסקריפט 6 עקב הדרכים המורכבות יותר שבהן ניתן היה להגדיר פרמטרים. הכוונה לפירוק פרמטרים וערכי ברירת מחדל לפרמטרים.
כדי להבין את הבעיה נבחן את הדוגמה הבאה:

<div dir="ltr">

```js
function doSomething(first = this) {
    "use strict";

    return first;
}
```

</div>

בדוגמה לעיל הפרמטר בשם
`first`
מקבל את ערך ברירת המחדל
`this`.
מה היינו מצפים שיהיה ערכו של
`first`?
הגדרות אקמהסקריפט 6 מורות למנועי ריצה של ג׳אווהסקריפט להתייחס לפרמטרים כאילו הם רצים במצב קפדני במצב שכזה.
לכן
`this`
אמור לקבל את הערך
`undefined`.
אך מימוש פרמטרים במצב קפדני כאשר
<span dir="ltr">`"use strict"`</span>
מופיע בתוך הפונקציה התגלה כבעייתי במיוחד מכיוון שערכים דיפולטיביים לפרמטרים יכולים להיות פונקציות בעצמם.
קושי זה הוביל לכך שרוב מנועי הריצה של ג׳אווהסקריפט לא מימשו שינוי זה.
(ולכן
`this`
יצביע על האובייקט הגלובלי).

כתוצאה מקושי זה במימוש, אקמהסקריפט 2016 אוסרת על פקודת
<span dir="ltr">`"use strict"`</span>
בתוך פונקציה שהפרמטרים שלה הינם פרמטרים מפורקים או בעלי ערכי ברירת מחדל.
רק
*פרמטרים פשוטים*
(*simple parameter lists*),
כאלו שאינם מכילים פרמטרים מפורקים או בעלי ערך דיפולטיבי, מותרים לשימוש כאשר פקודת
<span dir="ltr">`"use strict"`</span>
מופיעה בתוך הפונקציה.
להלן מספר דוגמאות:

<div dir="ltr">

```js
// תקין - שימוש בפרמטרים פשוטים
function okay(first, second) {
    "use strict";

    return first;
}

// שגיאה תחבירית
function notOkay1(first, second=first) {
    "use strict";

    return first;
}

// שגיאה תחבירית
function notOkay2({ first, second }) {
    "use strict";

    return first;
}
```

</div>

ניתן עדיין להשתמש בפקודת
<span dir="ltr">`"use strict"`</span>
ביחד עם פרמטרים פשוטים, ולכן הפונקציה
<span dir="ltr">`okay()`</span>
עובדת כמצופה
(בדיוק כמו שעבדה באקמהסקריפט 5).
הפונקציה
<span dir="ltr">`notOkay1()`</span>
זורקת שגיאה תחבירית מכיוון שלא ניתן להשתמש בפקודת
<span dir="ltr">`"use strict"`</span>
בתוך פונקציה בעלת ערכי ברירת מחדל לפרמטרים.
באופן דומה הפונקציה
<span dir="ltr">`notOkay2()`</span>
גם זורקת שגיאה תחבירית מכיוון שלא ניתן להשתמש בפקודת
<span dir="ltr">`"use strict"`</span>
בפונקציה עם פרמטרים מפורקים.

בהיבט הכללי, השינוי הנ״ל מבטל מקור לבלבול בקרב מפתחים ופותר בעיית מימוש עבור מנועי ריצה של ג׳אווהסקריפט.

</div>
