<div dir="rtl">

# עטיפת קוד במודולים

גישת ה ״שיתוף הכל״ של
ג׳אווהסקריפט
לטעינת קוד היא אחד מההיבטים המועדים לשגיאה והמבלבלים ביותר של השפה. שפות אחרות משתמשות במושגים כמו חבילות / פקג׳ס
(packages)
כדי להגדיר את היקף הקוד, אך עד
ECMAScript 6,
כל מה שהוגדר בכל קובץ ג׳אווהסקריפט של אפליקציה שיתף מרחב/סקופ גלובלי אחד. כאשר אפליקציות ווב הפכו מורכבות יותר והחלו להשתמש עוד יותר בג׳אווהסקריפט, גישה זו גרמה לבעיות שונות כמו: התנגשוות בין שמות ובעיות אבטחה. מטרה אחת של
ECMAScript 6
הייתה לפתור את בעיית הסקופ ולהכניס קצת סדר ליישומי ג׳אווהסקריפט. לשם כך נוצרו מודולים.

## מה זה מודולים?

*מודולים*
הם קבצי
ג׳אווהסקריפט
הנטענים במצב שונה
(בניגוד ל *סקריפטים*, הנטענים באופן הרגיל).
מצב שונה זה הכרחי מכיוון שלמודולים יש סמנטיקה שונה מאוד מאשר סקריפטים:

1. קוד המודול פועל באופן אוטומטי במצב קפדני
(strict mode),
ואין דרך לבטלו
1. משתנים שנוצרו ברמה העליונה של מודול אינם מתווספים אוטומטית לסקופ הגלובלי המשותף. הם קיימים רק בסקופ העליון של המודול.
1. הערך של
`this`
ברמה העליונה של המודול הוא
`undefined`.
1. מודולים אינם מאפשרים הערות בסגנון
HTML
בקוד
(מאפיין שנותר עוד מימיו המוקדמים של הדפדפן).
1. על המודולים לייצא כל מה שאמור להיות זמין לקוד מחוץ למודול.
1. מודולים רשאים לייבא ממודולים אחרים.

הבדלים אלה עשויים להיראות קטנים במבט ראשון, אך הם מייצגים שינוי משמעותי באופן טעינת קוד ג׳אווהסקריפט
והרצתו, עליו יורחב במהלך פרק זה. הכוח האמיתי של המודולים הוא היכולת לייצא ולייבא רק חלקים שאנו זקוקים להם, ולא כל מה שיש בקובץ. הבנה טובה של ייצוא וייבוא הינה יסודית להבנת האופן שבו מודולים שונים מסקריפטים.

## ייצוא בסיסי

ניתן להשתמש במילת המפתח
`export`
כדי לחשוף חלקים מהקוד למודולים אחרים. במקרה הפשוט ביותר, ניתן להציב
`export`
לפני כל הגדרת משתנה, פונקציה או מחלקה כדי לייצא אותו מהמודול, כך:

<div dir="ltr">

```js
// export data
export var color = "אדום";
export let name = "ניקולאס";
export const magicNumber = 7;

// export function
export function sum(num1, num2) {
  return num1 + num1;
}

// export class
export class Rectangle {
  constructor(length, width) {
    this.length = length;
    this.width = width;
  }
}

// this function is private to the module
function subtract(num1, num2) {
  return num1 - num2;
}

// define a function...
function multiply(num1, num2) {
  return num1 * num2;
}

// ...and then export it later
export { multiply };
```

</div>

יש לשים לב בדוגמא זו לכמה דברים. ראשית, מלבד מילת המפתח
`export`,
כל הצהרה זהה לחלוטין להצהרה בדרך הרגילה. לכל פונקציה או מחלקה מיוצאת יש גם שם;
הסיבה לכך היא שהייצוא של פונקציות והצהרות מחלקה דורשות שם. לא ניתן לייצא פונקציות או מחלקות אנונימיות באמצעות תחביר זה אלא אם כן משתמשים במילה
`default`
(
נדון בפירוט בסעיף
"ערכי ברירת מחדל במודולים"
).

בקוד מופיעה הפונקציה
<span dir="ltr">`multiply()`</span>,
שאינה מיוצאת כאשר היא מוגדרת.
זה קוד תקין כי לא חובה לייצא הצהרה:
ניתןגם לייצא הפניות/רפרנס. לבסוף, שימול לב לכך שדוגמה זו אינה מייצאת את הפונקציה
<span dir="ltr">`subtract()`</span>.
פונקציה זו לא תהיה נגישה מחוץ למודול זה מכיוון שמשתנים, פונקציות או מחלקות שלא מיוצאים במפורש נשארים פרטיים למודול.

## ייבוא בסיסי

ברגע שיש לך מודול שמייצא קוד, ניתן לגשת לפונקציונליות במודול אחר באמצעות מילת המפתח
`import`.
שני החלקים של משפט
`import`
הם המזהים שאנו מייבאים והמודול ממנו יש לייבא מזהים אלה.
זו הצורה הבסיסית של ההצהרה:

<div dir="ltr">

```js
import { identifier1, identifier2 } from "./example.js";
```

</div>

הסוגריים המסולסלות לאחר
`import`
מציינות את המזהים לייבוא ממודול נתון.
מילת המפתח
`from`
מציינת את המודול שממנו ניתן לייבא את המזהה הנתון. המודול מוגדר על ידי מחרוזת המייצגת את הנתיב למודול
(
הנקרא
<span dir="ltr">*module specifier*</span>
).
הדפדפנים משתמשים באותו פורמט נתיב שניתן להעביר לאלמנט
`<script>`,
כלומר יש לכלול סיומת קובץ. לעומת זאת,
Node.js
עוקב אחר המוסכמה המסורתית שלה להבדיל בין קבצים וחבילות מקומיים בהתבסס על קידומת מערכת קבצים. לדוגמה,
`example`
תהיה פקג׳ ו-
<span dir="ltr">`./example.js`</span>
תהיה קובץ מקומי.

!> רשימת החלקים לייבוא נראית דומה לאובייקט , אך אין מדובר באובייקט.

בעת ייבוא מזהה ממודול, הקוד פועל כאילו הוגדר באמצעות
`const`.
כלומר, לא ניתן להגדיר משתנה אחר בעל אותו שם
(כולל ייבוא מזהה אחר באותו שם),
להשתמש במזהה לפני משפט
`import`
או לשנות את ערכו.

### ייבוא מזהה בודד

נניח שהדוגמה הראשונה בסעיף "ייצוא בסיסי" היא במודול עם שם הקובץ
`example.js`.
ניתן לייבא ולהשתמש בחלקים מאותו מודול במספר דרכים. למשל, ניתן פשוט לייבא מזהה אחד:

<div dir="ltr">


```js
// ייבוא בודד
import { sum } from "./example.js";

console.log(sum(1, 2)); // 3

sum = 1; // שגיאה
```

</div>

למרות ש-
`example.js`
מייצאת יותר מפונקציה אחת בלבד, דוגמה זו מייבאת רק את הפונקציה
<span dir="ltr">`sum()`</span>.
אם ננסה להקצות ערך חדש ל
`sum`,
התוצאה היא שגיאה, מכיוון שלא ניתן להקצות ערך חדש לחלקים מיובאים.

?> הקפידו לכלול את
<span dir="ltr">`/`, `./`,</span>
או
<span dir="ltr">`../`</span>
בתחילת הקובץ שמייבאים לצורך התאמה טובה ביותר בין דפדפנים ו-
Node.js.

### ייבוא חלקי קוד מרובים

אם תרצו לייבא חלקים מרובים ממודול תוכלו לפרט אותן באופן מפורש כדלקמן:

<div dir="ltr">

```js
// ייבוא של מספר מזהים
import { sum, multiply, magicNumber } from "./example.js";
console.log(sum(1, magicNumber)); // 8
console.log(multiply(1, 2)); // 2
```

</div>

בדוגמה זו מיובאים שלושה חלקי קוד מהמודול:
`sum`, `multiply`
ו
`magicNumber`.
לאחר מכן הם משמשים כאילו הם הוגדרו באופן מקומי.

### ייבוא כל המודול

יש גם מקרה מיוחד המאפשר לנו לייבא את כל המודול כאובייקט יחיד. כל החלקים המיוצאים זמינים אז כתכונות על האובייקט. לדוגמה:

<div dir="ltr">

```js
// ייבוא הכל
import * as example from "./example.js";
console.log(example.sum(1, example.magicNumber)); // 8
console.log(example.multiply(1, 2)); // 2
```

</div>

בקוד זה, כל החלקים המיוצאים ב-
`example.js`
נטענים לאובייקט שנקרא
`example`.
לאחר מכן כל החלקים המיוצאים
(
פונקציית
<span dir="ltr">`sum()`</span>,
פונקציית
<span dir="ltr">`multiple()`</span>
ו-
`magicNumber`
)
זמינים לשימוש כתכונות באובייקט
`example`.
פורמט ייבוא זה נקרא ייבוא
*ניימספייס*
/
*מרחב שמות*
( *namespace import* )
מכיוון שהאובייקט
`example`
אינו קיים בתוך הקובץ
`example.js`.
במקום זה הוא נוצר כדי לשמש כאובייקט ניימספייס עבור כל החלקים המיוצאים של
`example.js`.

זכרו, שלא משנה כמה פעמים נעשה שימוש במודול בהצהרות
`import` ,
המודול ירוץ רק פעם אחת. לאחר הרצת וייבוא המודול, המודול נשמר בזיכרון ומשמש אותנו מחדש בכל פעם שמשפט אחר של
`import`
מפנה אליו. הסתכלו בדוגמה הבאה:

<div dir="ltr">

```js
import { sum } from "./example.js";
import { multiply } from "./example.js";
import { magicNumber } from "./example.js";
```

</div>

למרות שישנן שלוש הצהרות
`import`
במודול זה,
`example.js`
יבוצע רק פעם אחת. אם מודולים אחרים באותו יישום היו מייבאים חלקים מ-
`example.js`,
מודולים אלה ישתמשו באותו מופע מודול בו משתמש הקוד בדוגמה.

### מגבלות תחביר המודול

מגבלה חשובה הן של
`export`
והן של
`import`
היא שחובה להשתמש בהם מחוץ להצהרות ופונקציות. למשל, קוד זה יזרוק שגיאת תחביר:

<div dir="ltr">

```js
if (flag) { export flag; } // שגיאת תחביר
```

</div>

הצהרת
`export`
נמצאת בתוך הצהרת
`if`,
דבר שאינו תקין.
היצוא לא יכול להיות מותנה או להתבצע באופן דינמי בשום צורה שהיא.
אחת הסיבות לקיומו של תחביר כתיבת מודולים היא לאפשר למנוע
ג׳אווהסקריפט
לקבוע באופן סטטי מה מיוצא. ככזה, ניתן  להשתמש בפקודת
`export`
רק ברמה העליונה של המודול.

באופן דומה, לא ניתן להשתמש בפקודת
`import`
בתוך הצהרה;
ניתן להשתמש בו רק ברמה העליונה.
כלומר, קוד זה גם הוא זורק שגיאת תחביר:

<div dir="ltr">

```js
function tryImport() {
  // syntax error
  import flag from "./example.js";
}
```

</div>

לא ניתן לייבא חלקים בצורה דינמית מאותה סיבה שלא ניתן לייצא חלקים בצורה דינמית. מילות המפתח
`export`
ו
`import`
נועדו להיות סטטיות כך שכלים כמו עורכי טקסט יוכלו לדעת בקלות איזה מידע זמין ממודול.

### שינוי חלקים מיובאים

הצהרות
`import`
של
ECMAScript 6
יוצרות אפשרות קריאה בלבד למשתנים, פונקציות ומחלקות במקום להצביע לקוד כמו למשתנים רגילים. למרות שהמודול שמייבא את הקוד לא יכול לשנות את ערכו, המודול שמייצא את המזהה יכול. לדוגמה, נניח שתרצה להשתמש במודול זה:

<div dir="ltr">

```js
export var name = "ניקולאס";
export function setName(newName) {
  name = newName;
}
```

</div>

כאשר אתה מייבא את שתי הפונקציות האלה, הפונקציה
<span dir="ltr">`setName()`</span>
יכולה לשנות את הערך של
`name`:

<div dir="ltr">

```js
import { name, setName } from "./example.js";

console.log(name); // "ניקולאס"
setName("גרג");
console.log(name); // "גרג"

name = "Nicholas";  // שגיאה
```

</div>

הקריאה לפונקציה
<span dir="ltr">`setName("Greg")`</span>
חוזרת למודול שממנו מיוצא
<span dir="ltr">`setName()`</span>
ומבוצעת שם, ומגדירה את
`name`
ל
`"Greg"`.
שימו לב ששינוי זה משתקף אוטומטית בחלק
`name`
המיובא. הסיבה לכך היא ש
`name`
הוא השם המקומי למזהה
`name`
המיוצא.
`name`
המשמש בקוד לעיל וה
`name`
המשמש במודול המיובא ממנו אינם זהים.

## שינוי השם לחלקים מיובאים ומיוצאים

ייתכןולא נרצה להשתמש בשם המקורי של משתנה, פונקציה או מחלקה שמיובאים ממודול. למרבה המזל, ניתן לשנות את שם היצוא גם במהלך הייצוא וגם במהלך הייבוא.

במקרה הראשון, נניח שיש לך פונקציה שברצונך לייצא בשם אחר. ניתן להשתמש במילת המפתח
`as`
כדי לציין את השם של הפונקציה מחוץ למודול:

<div dir="ltr">

```js
function sum(num1, num2) {
  return num1 + num2;
}

export { sum as add };
```

</div>

כאן, הפונקציה
<span dir="ltr">`sum()`</span>
(
`sum`
הוא
*השם המקומי* -
<span dir="ltr">*local name*</span>
)
מיוצאת כ-
<span dir="ltr">`add()`</span>
(
`add`
הוא
*השם המיוצא* -
<span dir="ltr">*exported name*</span>
).
פירוש הדבר שכאשר מודול אחר מעוניין לייבא פונקציה זו,
יהיה עליו להשתמש בשם
`add`
במקום זאת:

<div dir="ltr">

```js
import { add } from "./example.js";
```

</div>

אם המודול שמייבא את הפונקציה רוצה להשתמש בשם אחר, הוא יכול גם להשתמש ב
`as`:

<div dir="ltr">

```js
import { add as sum } from "./example.js";
console.log(typeof add); // "undefined"
console.log(sum(1, 2)); // 3
```

</div>

קוד זה מייבא את הפונקציה
<span dir="ltr">`add()`</span>
באמצעות
*השם המיובא* -
<span dir="ltr">*`(import name)`*</span>
ומשנה את שמו ל-
<span dir="ltr">`sum()`</span>
(השם המקומי).
פירוש הדבר שאין במודול זה מזהה בשם
`add`.

### ערך דיפולטיבי במודולים

תחביר המודול מותאם לייצוא וייבוא של ערך דיפולטיבי ממודולים, מכיוון שדפוס זה היה נפוץ למדי במערכות מודולים אחרות, כמו
CommonJS
(
פורמט מודול
ג׳אווהסקריפט
אחר, שהפך לפופולרי על ידי
Node.js
).
ערך ברירת המחדל
<span dir="ltr">(*default value*)</span>
עבור מודול הוא משתנה, פונקציה או מחלקה שצוינו על ידי מילת המפתח
`default`,
וניתן להגדיר רק יצוא ערך דיפולטיבי אחד לכל מודול. שימוש במילת המפתח
`default`
עם יצוא מרובה יגרום לשגיאת תחביר.

### ייצוא ערכי ברירת מחדל

הנה דוגמה פשוטה המשתמשת במילת המפתח
`default`:

<div dir="ltr">

```js
export default function (num1, num2) {
  return num1 + num2;
}
```

</div>

מודול זה מייצא פונקציה כערך ברירת המחדל שלה. מילת המפתח
`default`
מציינת שמדובר בייצוא ברירת מחדל. הפונקציה אינה דורשת שם מכיוון שהמודול עצמו מייצג את הפונקציה.

ניתן גם לציין מזהה כיצוא ברירת המחדל על ידי הצבתו לאחר
`export default`,
כגון:

<div dir="ltr">

```js
function sum(num1, num2) {
  return num1 + num2;
}

export default sum;
```

</div>

כאן, הפונקציה
<span dir="ltr">`sum()`</span>
מוגדרת תחילה ומאוחרת מיוצאת כערך ברירת המחדל של המודול.
ייתכן שתרצה לבחור בגישה זו אם יש לחשב את ערך ברירת המחדל.

דרך שלישית לציין מזהה כיצוא ברירת המחדל היא באמצעות תחביר שינוי שם כדלקמן:

<div dir="ltr">

```js
function sum(num1, num2) {
  return num1 + num2;
}

export { sum as default };
```

</div>

למזהה
`default`
יש משמעות מיוחדת בייצוא שמות מחדש ומציין שערך צריך להיות ברירת המחדל עבור המודול. מכיוון ש
`default`
היא מילת מפתח ב-
ג׳אווהסקריפט,
לא ניתן להשתמש בה לשם משתנה, פונקציה או שם מחלקה
(ניתן להשתמש בה כשם מאפיין).
אז השימוש ב
`default`
לשם שינוי יצוא הוא מקרה מיוחד ליצירת עקביות עם אופן ההגדרה של יצוא שאינו ברירת מחדל. תחביר זה שימושי אם ברצונך להשתמש במשפט
`default`
יחיד כדי לציין יצוא מרובים, כולל ברירת המחדל, בבת אחת.

### ייבוא ערכי ברירת מחדל

ניתן לייבא ערך ברירת מחדל ממודול באמצעות התחביר הבא:

<div dir="ltr">

```js
// ייבוא הערך הדיפולטיבי
import sum from "./example.js";

console.log(sum(1, 2)); // 3
```

</div>

הצהרת ייבוא זו מייבאת את הערך הדיפולטיבי מהמודול
`example.js`.
שים לב כי לא נעשה שימוש בסוגריים מסולתלים, בשונה ממה שהיינו רואים בייבוא רגיל. השם המקומי
`sum`
משמש לייצוג כל ערך דיפולטיבי שהמודול מייצא.
התחביר הזה הוא הנקי ביותר, ויוצרי
ECMAScript 6
מצפים שהוא יהיה צורת הייבוא הדומיננטית באינטרנט.

עבור מודולים המייצאים גם ערך דיפולטיבי וגם ערכים אחרים, ניתן לייבא את כל הקוד המיוצא בשורה אחת. לדוגמה, נניח שקיים המודול הבא:

<div dir="ltr">

```js
export let color = "אדום";

export default function (num1, num2) {
  return num1 + num2;
}
```

</div>

ניתן לייבא הן את
`color`
והן את הערך הדיפולטיבי באמצעות הצהרת
`import`
הבאה:

<div dir="ltr">

```js
import sum, { color } from "./example.js";

console.log(sum(1, 2)); // 3
console.log(color); // "אדום"
```

</div>

הפסיק מפריד בין הערך המוגדר כברירת מחדל לבין הערכים שאינם דיפולטיביים, המוקפים גם בסוגריים מסולסלים. חשוב לזכור שערך דיפולטיבי חייב לבוא לפני ערכים רגילים בהצהרת
`import`.

כמו בייצוא, ניתן לייבא ערך דיפולטיבי בעזרת התחביר המשנה את שם הערך:

<div dir="ltr">

```js
// מקביל לדוגמה הקודמת
import { default as sum, color } from "example";

console.log(sum(1, 2)); // 3
console.log(color); // "אדום"
```

</div>

בקוד זה, ייצוא ברירת המחדל
(`default`)
מקבל את השם
`sum`
וייצוא נוסף של
`color`
מיובא. דוגמא זו מקבילה לדוגמא הקודמת.

## ייצוא חוזר של קוד

יכול להיות שנרצה לייצא מחדש
<span dir="ltr">(re-export)</span>
ערך שהמודול שלנו ייבא (למשל, אם אנו יוצרים ספרייה מכמה מודולים קטנים). באפשרותנו לייצא מחדש ערך מיובא עם הדפוסים שכבר נדונו בפרק זה באופן הבא:

<div dir="ltr">

```js
import { sum } from "./example.js";
export { sum };
```

</div>

זה עובד, אבל הצהרה אחת יכולה גם לעשות את אותו הדבר:

<div dir="ltr">

```js
export { sum } from "./example.js";
```

</div>

צורה זו של
`export`
בודקת את המודול שצוין עבור ההצהרה על
`sum`
ואז מייצאת אותו. כמובן, ניתן גם לבחור לייצא שם אחר באותו ערך:

<div dir="ltr">

```js
export { sum as add } from "./example.js";
```

</div>

כאן,
`sum`
מיובא מ-
<span dir="ltr">`"./example.js"`</span>
ואז מיוצא כ
`add`.

אם נרצה לייצא הכל ממודול אחר, נוכל להשתמש בתבנית
`*`:

<div dir="ltr">

```js
export * from "./example.js";
```

</div>

כאשר אנו מייצאים הכל, אנו כוללים את כל המזהים שאינם דיפולטיביים. לדוגמא, אם ל-
`example.js`
יש ייצוא דיפולטיבי, יהיה עליכם לייבא אותו במפורש ואז לייצא אותו במפורש.

## ייבוא ללא הצהרה

ייתכן שמודולים מסוימים לא מייצאים שום דבר, ובמקום זאת רק מבצעים שינויים באובייקטים בסקופ הגלובלי. למרות שמשתנים, פונקציות ומחלקות ברמה העליונה במודולים אינם מגיעים באופן אוטומטי לסקופ הגלובלי, אין הדבר אומר שמודולים אינם יכולים לגשת לסקופ הגלובלי. ההגדרות המשותפות של אובייקטים מובנים כגון
`Array`
ו
`Object`
נגישים בתוך מודול ושינויים באובייקטים אלה יבואו לידי ביטוי במודולים אחרים.

לדוגמה, אם נרצה להוסיף שיטת
<span dir="ltr">`pushAll()`</span>
לכל המערכים, נוכל להגדיר מודול כזה:

<div dir="ltr">

```js
// מודול ללא ייבוא או ייצוא
Array.prototype.pushAll = function (items) {
  // items
  // חייב להיות מערך
  if (!Array.isArray(items)) {
    throw new TypeError("Argument must be an array.");
  }

  // משתמשים במתודה
  // push
  // המובנית יחד עם אופרטור הפיזור
  return this.push(...items);
};
```

</div>

זהו מודול תקף למרות שאין בו ייצוא או יבוא. ניתן להשתמש בקוד זה גם כמודול וגם כסקריפט. מכיוון שהוא לא מייצא דבר, ניתן להשתמש בייבוא פשוט כדי להריץ אותו:

<div dir="ltr">

```js
import "./example.js";

let colors = ["red", "green", "blue"];
let items = [];

items.pushAll(colors);
```

</div>

קוד זה מייבא ומריץ את המודול המכיל את המתודה
<span dir="ltr">`pushAll()`</span>,
כך ש
<span dir="ltr">`pushAll()`</span>
נוסף לפרוטוטייפ של המערך. פירוש הדבר ש-
<span dir="ltr">`pushAll()`</span>
זמין כעת לשימוש בכל המערכים שבתוך מודול זה.

!> יבוא ללא שימוש בחלקים מיובאים כנראה שישמש להשפעה על הקוד הגלובלי לשם תאימות ומניעת שגיאות ריצה
<span dir="ltr">(polyfills and shims)</span>.

## טעינת מודולים

בעוד ש-
ECMAScript 6
מגדיר את התחביר עבור כתיבת מודולים, הוא אינו מגדיר כיצד לטעון אותם. זה מפני שהאפיון אמור להיות אגנוסטי מבחינת היישום. במקום לנסות ליצור אפיון יחיד שיעבוד בכל סביבת-
ג׳אווהסקריפט,
ECMAScript 6
מציין רק את התחביר ועושה אבסטרקציה עבור מנגנון הטעינה לפעולה פנימית לא מוגדרת הנקראת `HostResolveImportedModule`.
דפדפני האינטרנט ו-
Node.js
צריכים להחליט בעצמם כיצד ליישם את
`HostResolveImportedModule`
באופן הגיוני לסביבותיהם.

### שימוש במודולים בדפדפני אינטרנט

עוד לפני
ECMAScript 6,
היו לדפדפני האינטרנט דרכים מרובות לטעון
ג׳אווהסקריפט
ביישום אינטרנט. אפשרויות טעינת סקריפט אלה הן:

1. טעינת קבצי קוד
ג׳אווהסקריפט
באמצעות רכיב
`<script>`
עם התכונה
`src`
המציין מיקום ממנו ניתן לטעון את הקוד.
1. הטמעת קוד
ג׳אווהסקריפט
בדף באמצעות האלמנט
`<script>`
ללא התכונה
`src`.
1. טעינת קבצי קוד
ג׳אווהסקריפט
לביצוע כוורקר
worker
(כגון
ווב וורקר -
web worker
או
סרביס וורקר -
service worker).

על מנת לתמוך במודולים באופן מלא, דפדפני האינטרנט נאלצו לעדכן כל אחד מהמנגנונים הללו. פרטים אלה מוגדרים באפיון ה-
HTML
ואני אסכם אותם בחלק זה.

#### שימוש במודולים עם `<script>`

התנהגות ברירת המחדל של האלמנט
`<script>`
היא לטעון קבצי
ג׳אווהסקריפט
כסקריפטים
(לא מודולים).
זה קורה כאשר התכונה
`type`
חסרה או כאשר התכונה
`type`
מכילה את הערך של
ג׳אווהסקריפט
(
כגון
`"text/javascript"`
).
האלמנט
`<script>`
יכול להריץ קוד פנימי / אינליין
(inline code)
או לטעון את הקובץ שצוין ב-
`src` .
כדי לתמוך במודולים, הערך
`"module"`
נוסף כאופציה ב
`type` .
הגדרת
`type`
ל
`"module"`
אומרת לדפדפן לטעון כל קוד אינליין או קוד הכלול בקובץ שצוין על ידי
`src`
כמודול במקום סקריפט. הנה דוגמה פשוטה:

<div dir="ltr">

```html
<!-- טעינת קובץ ג׳אווהסקריפט מסוג מודול -->
<script type="module" src="module.js"></script>

<!-- טעינת מודול אינליין -->
<script type="module">
  import { sum } from "./example.js";

  let result = sum(1, 2);
</script>
```

</div>

האלמנט הראשון מסוג
`<script>`
בדוגמה זו טוען קובץ מודול חיצוני באמצעות התכונה
`src`.
ההבדל היחיד יחסית לטעינת סקריפט הוא ש
`"module"`
ניתן כערך עבור
`type`.
האלמנט השני מסוג
`<script>`
מכיל מודול המוטמע ישירות בדף האינטרנט. המשתנה
`result`
אינו נחשף באופן גלובלי מכיוון שהוא קיים רק בתוך המודול
(
כהגדרתו על ידי האלמנט
`<script>`
)
ולכן אינו מתווסף ל
`window`
בתור תכונה.

כפי שניתן לראות, טעינת מודולים בדפי אינטרנט הינה פעולה פשוטה ודומה לטעינת סקריפטים. עם זאת, ישנם כמה הבדלים באופן טעינת המודולים.

!> יתכן ששמתם לב ש-
`"module"`
אינו סוג תוכן כמו סוג
`"text/javascript"`.
קבצי
JavaScript
מסוג מודול מגיעים עם אותו סוג תוכן כמו קבצי
JavaScript
מסוג סקריפט, כך שלא ניתן להבדיל ביניהם על בסיס סוג תוכן. כמו כן, דפדפנים מתעלמים מאלמנטים של
`<script>`
כאשר
`type`
אינו מזוהה, כך שדפדפנים שאינם תומכים במודולים יתעלמו אוטומטית משורת
<span dir="ltr">`<script type="module">`</span>,
ויספקו תאימות טובה לאחור.

#### רצף טעינת מודולים בדפדפני אינטרנט

המודולים ייחודיים בכך שבניגוד לסקריפט, הם עשויים להשתמש ב
`import`
כדי לטעון קבצים אחרים. כדי לתמוך בפונקציונליות זו,
<span dir="ltr">`<script type="module">`</span>
תמיד מתנהג כאילו חל המאפיין מסוג
`defer`.

המאפיין
`defer`
הינו אופציונלי לטעינת קבצי סקריפט אך מתקיים תמיד בעת טעינת מודולים. הורדת קובץ המודול מתחילה ברגע שדף ה-
HTML
נתקל ב-
<span dir="ltr">`<script type="module">`</span>
בתכונה
`src`
אך אינו מבוצע עד לאחר עיבוד המסמך כולו. המודולים מבוצעים גם לפי סדר הופעתם בקובץ ה-
HTML.
פירוש הדבר שה-

<span dir="ltr">`<script type="module">`</span>
הראשון מובטח תמיד כי יבוצע לפני השני, גם אם מודול אחד מכיל קוד מוטמע במקום לציין
`src`.
לדוגמה:

<div dir="ltr">

```html
<!-- ירוץ ראשון -->
<script type="module" src="module1.js"></script>

<!-- ירוץ שני -->
<script type="module">
  import { sum } from "./example.js";

  let result = sum(1, 2);
</script>

<!-- ירוץ שלישי -->
<script type="module" src="module2.js"></script>
```

</div>

שלושת האלמנטים מסוג
`<script>`
רצים לפי סדר הגדרתם, ולכן מובטח ש-
`module1.js`
ירוץ לפני המודול עם הקוד המוטמע, ומובטח כי המודול עם הקוד המוטמע יבוצע לפני
`module2.js`.

כל מודול יכול לבצע
`import`
ממודול אחד או יותר, מה שמסבך את המצב. זו הסיבה שמודולים מעובדים תחילה כדי לזהות את כל פקודות ה
`import`.
כל פקודת
`import`
מפעילה אחזור
-
fetch
(מהרשת או מזיכרון המטמון)
,ואף מודול לא ירוץ עד שכל הקוד שעשו לו
`import`
נטען. שלושת האלמנטים
`<script>`
אלו מבוצעים לפי הסדר. הם מוגדרים, ולכן מובטח ש-
`module1.js`
יבוצע לפני המודול המוטבע, ומובטח כי המודול המוטבע יבוצע לפני
`module2.js`.

כל המודולים, הן אלה שנכללו במפורש באמצעות
<span dir="ltr">`<script type="module">`</span>
וגם אלה שנכללו במשתמע באמצעות
`import`,
נטענים ומבוצעים לפי הסדר. בדוגמה הקודמת, רצף הטעינה השלם הוא:

1. הורדה ועיבוד
(parse)
של
`module1.js`.
1. הורדה רקורסיבית ועיבוד של הפניות
`import`
ב-
`module1.js`.
1. עיבוד של המודול האינליין.
1. הורדה רקורסיבית של הפניות
`import`
במודול האינליין.
1. הורדה ועיבוד
`module2.js`.
1. הורדה רקורסיבית ועיבוד הפניות
`import`
ב-
`module2.js`

לאחר סיום הטעינה, שום קוד לא ירוץ עד לאחר עיבוד המסמך לחלוטין. לאחר השלמת עיבוד הדף, מתרחשות הפעולות הבאות:

1. הרצה רקורסיבית של פקודות
`import`
עבור
`module1.js`.
1. הרצת
`module1.js`.
1. הרצה רקורסיבית של פקודות
`import`
עבור המודול האינליין.
1. הרצת המודול האינליין.
1. הרצה רקורסיבית של פקודות
`import`
עבור
`module2.js`.
1. הרצת
`module2.js`.

שימו לב כי המודול האינליין מתנהג כמו שני המודולים האחרים, אלא אין צורך להוריד את הקוד תחילה. אחרת, רצף טעינת הפניות
`import`
והרצת המודולים זהה לחלוטין.

!> מתעלמים מהמאפיין
`defer`
ב-
<span dir="ltr">`<script type="module">`</span>
מכיוון האלמנט כבר מתנהג כאילו קיים המאפיין
`defer`.

#### טעינה של מודול אסינכרוני בדפדפנים

ייתכן שמוכר לכם המאפיין
(attribute)
`async`
באלמנט מסוג
`<script>`.
בשימוש עם סקריפטים,
`async`
גורם להרצת קובץ הסקריפט ברגע שהקובץ הורד ועובד לחלוטין. סדר הסקריפטים מסוג
`async`
בדף אינו משפיע על סדר ביצוע הסקריפטים. הסקריפטים מבוצעים תמיד ברגע שהסתיימה את ההורדה לשהם מבלי להמתין לסיום עיבוד הדף המכיל אותם.

ניתן להחיל את
`async`
גם על מודולים. השימוש ב-
`async`
ב-
<span dir="ltr">`<script type="module">`</span>
גורם למודול לפעול באופן דומה לסקריפט. ההבדל היחיד הוא שכל הפניות ה
`import`
עבור המודול יורדו לפני הרצת המודול עצמו. זה מבטיח שכל המשאבים שהמודול צורך יורדו לפני הרצת המודול;
אך עם זאת, לא ניתן לדעת באופן וודאי
*מתי*
ירוץ המודול.
לדוגמה:

<div dir="ltr">

```html
<!-- אין וודאות לגבי איזה מודול ירוץ קודם -->
<script type="module" async src="module1.js"></script>
<script type="module" async src="module2.js"></script>
```

</div>

בדוגמה זו, ישנם שני מודולים הנטענים בצורה אסינכרונית. לא ניתן לדעת איזה מודול ירוץ קודם רק על ידי התבוננות בקוד. אם
`module1.js`
יורד קודם
(
כולל כל משאבי ה
`import`
שלו
),
הוא ירוץ ראשון. אם המודול
`module2.js`
יורד קודם מהשרת אז הוא יופעל קודם.

## טעינת מודולים כוורקר

וורקרים
(Workers),
כמו
web workers
ו
service workers,
מבצעים קוד
JavaScript
מחוץ להקשר
(context)
דף האינטרנט. יצירת
worker
חדש כוללת יצירת מופע חדש
`Worker`
(או מחלקה אחרת)
והעברת המיקום של קובץ
JavaScript.
מנגנון הטעינה המוגדר כברירת מחדל הוא טעינת קבצים כסקריפטים, כך:

<div dir="ltr">

```js
// טעינת הקובץ
// script.js
// כסקריפט
let worker = new Worker("script.js");
```

</div>

כדי לתמוך בטעינת מודולים, מפתחי תקן
HTML
הוסיפו ארגומנט שני לקונסטרקטור. הארגומנט השני הוא אובייקט עם תכונה
`type`
עם ערך ברירת המחדל של
`"script"`.
ניתן להגדיר
`type`
ל
`"module"`
על מנת לטעון קבצי מודול:

<div dir="ltr">

```js
// טעינת הקובץ
// module.js
// כמודול
let worker = new Worker("module.js", { type: "module" });
```

</div>

דוגמה זו טוענת את
`module.js`
כמודול במקום סקריפט על ידי העברת ארגומנט שני עם
`"module"`
כערך התכונה
`type`.
(
התכונה
`type`
נועדה לחקות פעולת המאפיין
`type`
של אלמנט
`<script>`
שמבדילה בין מודולים
וסקריפטים.
)
הארגומנט השני נתמך לכל סוגי הוורקרים בדפדפן.

מודולים מסוג
Worker
זהים בדרך כלל לסקריפטים של
Worker,
אך ישנם כמה יוצאים מן הכלל. ראשית, סקריפטים של
Worker
ניתנים להורדה רק מאותו מקור / אוריג׳ין
(origin)
כמו דף האינטרנט שבו מפנים אליו, אך מודולי
Worker
אינם מוגבלים באותה מידה. למרות שעבור מודולי
Worker
יש אותה הגדרת ברירת המחדל, הם רשאים גם להוריד קבצים עם הגדרות הדר
של שיתוף קבצים מאוריג׳ין שונה
של
<span dir="ltr">
CORS (Cross-Origin Resource Sharing Sharing) headers
</span>
כדי לאפשר גישה. שנית, בעוד שוורקר סקריפט יכול להשתמש במתודה
<span dir="ltr">`self.importScripts()`</span>
לטעינת סקריפטים נוספים,
הדבר אינו אפשרי במודולי
Worker
מכיוון שיש להשתמש במקום זאת בפקודת
`import`.

### איתור מודול בדפדפן

<span dir="ltr">Browser Module Specifier Resolution</span>

כל הדוגמאות עד נקודה זו בפרק השתמשו בנתיב יחסי
של מודול
<span dir="ltr">(relative module specifier)</span>
כגון
<span dir="ltr">`"./example.js"`</span>.
הדפדפנים דורשים שמיקום המודול יהיה באחד מהפורמטים הבאים:

* מתחיל עם `/` כדי לאתר החל מספריית המקור
<span dir="ltr">(root directory)</span>
* מתחיל עם `/.` כדי לאתר החל מהספריה הנוכחית
* מתחיל עם `/..` -כדי לאתר החל מספריית האב
* פורמט מסוג
URL

לדוגמא, נניח שיש לך קובץ מודול הממוקם בכתובת
`https://www.example.com/modules/module.js`
המכיל את הקוד הבא:

<div dir="ltr">

```js
// מייבא קוד מ
// https://www.example.com/modules/example1.js
import { first } from "./example1.js";

// מייבא קוד מ
// https://www.example.com/example2.js
import { second } from "../example2.js";

// מייבא קוד מ
// https://www.example.com/example3.js
import { third } from "/example3.js";

// מייבא קוד מ
// https://www2.example.com/example4.js
import { fourth } from "https://www2.example.com/example4.js";
```

</div>

כל אחד ממזהי המודולים בדוגמה זו תקף לשימוש בדפדפן, כולל כתובת האתר המלאה בשורה האחרונה
(
יהיה עליך להיות בטוח ש-
`ww2.example.com`
הגדיר כהלכה את שיתוף המשאבים המקוריים שלו
(CORS)
כותרות כדי לאפשר טעינה בין דומיינים שונים
)
.אלה הם הפורמטים היחידים של מזהים של מודול שהדפדפנים יכולים לאתר כברירת מחדל
(
אם כי האפיון עבור טעינת המודולים שעדיין לא הושלם יספק דרכים לאתר פורמטים אחרים
).
כלומר, חלק מאיפיון המודולים הרגיל למראה אינו תקף בדפדפנים ויגרום לשגיאה, כגון:

<div dir="ltr">

```js
// לא תקין - אינו מתחיל ב
// /, ./, או ../
import { first } from "example.js";

// לא תקין - אינו מתחיל ב
// /, ./, או ../
import { second } from "example/index.js";
```

</div>

לא ניתן לטעון את כל אחד ממזהי המודולים הללו על ידי הדפדפן. שני המזהים של המודולים הם בפורמט לא תקין
(חסרים תווי ההתחלה הנכונים)
למרות ששניהם יעבדו כאשר הם משמשים כערך של
`src`
באלמנט
`<script>`.
זהו הבדל מכוון בהתנהגות בין
`<script>`
ל-
`import`.

## סיכום

ECMAScript 6
הוסיפה מודולים לשפה כדרך לארוז ולעטוף פונקציונליות. מודולים מתנהגים אחרת מאשר סקריפטים, מכיוון שהם אינם משנים את הסקופ הגלובלי עם המשתנים, הפונקציות והמחלקות ברמה העליונה שלהם, ו
`this`
הוא
`undefined`.
כדי להשיג התנהגות זו, מודולים נטענים בצורה שונה.

עליך לייצא כל פונקציונליות שתרצה להעמיד למי שצורך את  המודול. ניתן לייצא משתנים, פונקציות ומחלקות, ויש גם אפשרות לייצוא דיפולטיבי אחד כברירת מחדל עבור כל מודול. לאחר הגדרת הייצוא, מודול אחר יכול לייבא את כל השמות המיוצאים או חלקם. משתנים אלה מתנהגים כאילו הוגדרו על ידי
`const`
ופועלים בתור משתנים מוגדרים בבלוק של קוד שלא ניתן להגדיר מחדש באותו מודול.

מודולים לא צריכים לייצא שום דבר אם הם מבצעים פעולה  בסקופ הגלובלי. ניתן למעשה לייבא ממודול כזה מבלי להכניס מזהים לתוך המודול.

מכיוון שמודולים רצים במצב אחר מסקריפט, הדפדפנים הוסיפו את
<span dir="ltr">`<script type="module">`</span>
כדי לאותת לדפדפן שיש להריץ את קובץ המקור או את הקוד האינליין כמודול. קבצי מודולים שטעונים על ידי-
<span dir="ltr">`<script type="module">`</span>
נטענים כאילו מוחל עליהם מאפיין
`defer`.
המודולים מבוצעים גם לפי סדר הופעתם בדף המכיל אותם לאחר העיבוד המלא של הדף.

</div>